From bad4d9b0b0ccc05061e4dcb9013d88407a04bf5a Mon Sep 17 00:00:00 2001
From: lixuqing <lixuqing2007@126.com>
Date: Thu, 5 Sep 2019 22:02:18 +0800
Subject: [PATCH] add audioserver and surfaceflinger

---
 .../{ => makefile}/ninja/ninja-manual.txt     |   0
 .../audioserver/AudioFlinger/AudioFlinger.cpp |  10 +-
 .../AudioFlinger/DevicesFactoryHalHybrid.cpp  | 131 ++++
 .../AudioFlinger/EffectsFactoryHalHidl.cpp    |  19 +
 .../EffectsFactoryHalInterface.cpp            |   0
 .../AudioPolicyService/AudioGain.cpp          |   7 +
 .../AudioPolicyService/AudioPolicyConfig.cpp  | 104 ++++
 .../AudioPolicyService/AudioPolicyManager.cpp |  42 +-
 .../AudioPolicyService/AudioPolicyService.cpp |   2 +-
 .../AudioPolicyService/AudioProfile.cpp       |  24 +
 .../AudioPolicyService/AudioRoute.cpp         |  37 ++
 .../AudioPolicyService/DeviceDescriptor.cpp   |  26 +
 .../audioserver/AudioPolicyService/Engine.cpp |  26 +
 .../AudioPolicyService/EngineInstance.cpp     |  19 +
 .../AudioPolicyService/HwModule.cpp           | 229 +++++++
 .../AudioPolicyService/IOProfile.cpp          |  42 ++
 .../AudioPolicyService/PolicySerializer.cpp   | 186 ++++--
 .../AudioPolicyService/VolumeCurve.cpp        |  53 ++
 .../media/audioserver/audioserver.txt         |   7 +
 .../media/audioserver/main_audioserver.cpp    |   3 +
 .../BufferQueue/BufferQueue.cpp               |  21 +
 .../BufferQueue/BufferQueueConsumer.cpp       |  11 +
 .../BufferQueue/BufferQueueCore.cpp           |  73 +++
 .../BufferQueue/BufferQueueProducer.cpp       |  20 +
 .../media/surfaceflinger/Client.cpp           |  83 +++
 .../media/surfaceflinger/ComposerService.cpp  |  30 +
 .../media/surfaceflinger/DispSync.cpp         |  46 ++
 .../media/surfaceflinger/DispSyncSource.cpp   |  22 +
 .../surfaceflinger/Layer/BufferLayer.cpp      |  74 +++
 .../media/surfaceflinger/Layer/Layer.cpp      |  84 +++
 .../media/surfaceflinger/Layer/Texture.cpp    |   9 +
 .../media/surfaceflinger/MessageQueue.cpp     |  94 +++
 .../RenderEngine/GLES20RenderEngine.cpp       |  52 ++
 .../RenderEngine/GLExtensions.cpp             |  67 ++
 .../RenderEngine/RenderEngine.cpp             | 123 ++++
 .../surfaceflinger/RenderEngine/Surface.cpp   |   8 +
 .../surfaceflinger/SurfaceComposerClient.cpp  |  82 +++
 .../media/surfaceflinger/SurfaceFlinger.cpp   | 425 +++++++++++++
 .../media/surfaceflinger/SurfaceFlingerBE.cpp |  23 +
 .../surfaceflinger/SurfaceInterceptor.cpp     |  32 +
 .../surfaceflinger/main_surfaceflinger.cpp    |  85 +++
 .../media/surfaceflinger/surfaceflinger.txt   |  24 +
 temp/0001-debug-LOCAL_PREBUILT_JNI_LIBS.patch | 585 ------------------
 temp/Android.mk                               |  50 --
 tools/update_libs.sh                          |  10 +-
 45 files changed, 2402 insertions(+), 698 deletions(-)
 rename android-auto-9-notes/build/asop-build-tools/{ => makefile}/ninja/ninja-manual.txt (100%)
 create mode 100644 android-auto-9-notes/media/audioserver/AudioFlinger/DevicesFactoryHalHybrid.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalHidl.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalInterface.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/AudioGain.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyConfig.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/AudioProfile.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/AudioRoute.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/DeviceDescriptor.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/Engine.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/EngineInstance.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/HwModule.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/IOProfile.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/AudioPolicyService/VolumeCurve.cpp
 create mode 100644 android-auto-9-notes/media/audioserver/audioserver.txt
 create mode 100644 android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueue.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueConsumer.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueCore.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueProducer.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/Client.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/ComposerService.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/DispSync.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/DispSyncSource.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/Layer/BufferLayer.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/Layer/Layer.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/Layer/Texture.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/MessageQueue.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/RenderEngine/GLExtensions.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/RenderEngine/RenderEngine.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/RenderEngine/Surface.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/SurfaceComposerClient.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/SurfaceFlinger.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/SurfaceFlingerBE.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/SurfaceInterceptor.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/main_surfaceflinger.cpp
 create mode 100644 android-auto-9-notes/media/surfaceflinger/surfaceflinger.txt
 delete mode 100644 temp/0001-debug-LOCAL_PREBUILT_JNI_LIBS.patch
 delete mode 100644 temp/Android.mk

diff --git a/android-auto-9-notes/build/asop-build-tools/ninja/ninja-manual.txt b/android-auto-9-notes/build/asop-build-tools/makefile/ninja/ninja-manual.txt
similarity index 100%
rename from android-auto-9-notes/build/asop-build-tools/ninja/ninja-manual.txt
rename to android-auto-9-notes/build/asop-build-tools/makefile/ninja/ninja-manual.txt
diff --git a/android-auto-9-notes/media/audioserver/AudioFlinger/AudioFlinger.cpp b/android-auto-9-notes/media/audioserver/AudioFlinger/AudioFlinger.cpp
index 911c518..bd5e743 100644
--- a/android-auto-9-notes/media/audioserver/AudioFlinger/AudioFlinger.cpp
+++ b/android-auto-9-notes/media/audioserver/AudioFlinger/AudioFlinger.cpp
@@ -98,7 +98,11 @@ void AudioFlinger::onFirstRef()
     gAudioFlinger = this;
 }
 
-
+/**
+ * 
+ * 这里是有AudioPolicyService调用
+ * 
+ */
 audio_module_handle_t AudioFlinger::loadHwModule(const char *name)
 {
     if (name == NULL) {
@@ -122,7 +126,6 @@ audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)
     }
 
     sp<DeviceHalInterface> dev;
-
     int rc = mDevicesFactoryHal->openDevice(name, &dev);
     if (rc) {
         ALOGE("loadHwModule() error %d loading module %s", rc, name);
@@ -146,6 +149,9 @@ audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)
     {  // scope for auto-lock pattern
         AutoMutex lock(mHardwareLock);
 
+        /**
+         * 第一次 loadHwModule_l 初始化 mMasterVolume 和 mMasterMute
+         */
         if (0 == mAudioHwDevs.size()) {
             mHardwareStatus = AUDIO_HW_GET_MASTER_VOLUME;
             float mv;
diff --git a/android-auto-9-notes/media/audioserver/AudioFlinger/DevicesFactoryHalHybrid.cpp b/android-auto-9-notes/media/audioserver/AudioFlinger/DevicesFactoryHalHybrid.cpp
new file mode 100644
index 0000000..729b32a
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioFlinger/DevicesFactoryHalHybrid.cpp
@@ -0,0 +1,131 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/DevicesFactoryHalInterface.cpp
+sp<DevicesFactoryHalInterface> DevicesFactoryHalInterface::create() {
+    if (hardware::audio::V4_0::IDevicesFactory::getService() != nullptr) {
+        return new V4_0::DevicesFactoryHalHybrid();
+    }
+    if (hardware::audio::V2_0::IDevicesFactory::getService() != nullptr) {
+        return new DevicesFactoryHalHybrid();
+    }
+    return nullptr;
+}
+
+
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/4.0/DevicesFactoryHalHybrid.cpp
+/**
+ *     
+ */
+DevicesFactoryHalHybrid::DevicesFactoryHalHybrid()
+        : mLocalFactory(new DevicesFactoryHalLocal()), //sp<DevicesFactoryHalInterface> mLocalFactory;
+          mHidlFactory(new DevicesFactoryHalHidl()) {   //  sp<DevicesFactoryHalInterface> mHidlFactory;
+}
+
+
+status_t DevicesFactoryHalHybrid::openDevice(const char *name, sp<DeviceHalInterface> *device) {
+    /**
+     * @    system/media/audio/include/system/audio.h:1124:#define AUDIO_HARDWARE_MODULE_ID_A2DP "a2dp"
+     * @    system/media/audio/include/system/audio.h:1129:#define AUDIO_HARDWARE_MODULE_ID_HEARING_AID "hearing_aid"
+     */
+    if (mHidlFactory != 0 && strcmp(AUDIO_HARDWARE_MODULE_ID_A2DP, name) != 0 &&
+        strcmp(AUDIO_HARDWARE_MODULE_ID_HEARING_AID, name) != 0) {
+            /**
+             * primary
+             * usb
+             * r_submix
+             */
+        return mHidlFactory->openDevice(name, device);
+    }
+    /**
+     * a2dp
+     */
+    return mLocalFactory->openDevice(name, device);
+}
+
+//  @   
+DevicesFactoryHalHidl::DevicesFactoryHalHidl() {
+    mDevicesFactory = IDevicesFactory::getService();
+    if (mDevicesFactory != 0) {
+        // It is assumed that DevicesFactory is owned by AudioFlinger
+        // and thus have the same lifespan.
+        mDevicesFactory->linkToDeath(HalDeathHandler::getInstance(), 0 /*cookie*/);
+    } else {
+        ALOGE("Failed to obtain IDevicesFactory service, terminating process.");
+        exit(1);
+    }
+    // The MSD factory is optional
+    //  system/media/audio/include/system/audio.h:1143:#define AUDIO_HAL_SERVICE_NAME_MSD "msd"
+    /**
+     * 这里没有该服务
+     */
+    mDevicesFactoryMsd = IDevicesFactory::getService(AUDIO_HAL_SERVICE_NAME_MSD);
+    // TODO: Register death handler, and add 'restart' directive to audioserver.rc
+}
+
+
+status_t DevicesFactoryHalHidl::openDevice(const char *name, sp<DeviceHalInterface> *device) {
+    if (mDevicesFactory == 0) return NO_INIT;
+    Result retval = Result::NOT_INITIALIZED;
+    Return<void> ret = mDevicesFactory->openDevice(
+            name,
+            [&](Result r, const sp<IDevice>& result) {
+                retval = r;
+                if (retval == Result::OK) {
+                    //  @ /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/4.0/DeviceHalHidl.cpp  
+                    *device = new DeviceHalHidl(result);
+                }
+            });
+    if (ret.isOk()) {
+        if (retval == Result::OK) return OK;
+        else if (retval == Result::INVALID_ARGUMENTS) return BAD_VALUE;
+        else return NO_INIT;
+    }
+    return FAILED_TRANSACTION;
+}
+
+
+
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/4.0/DevicesFactoryHalLocal.cpp
+/**
+ * a2dp
+ */
+status_t DevicesFactoryHalLocal::openDevice(const char *name, sp<DeviceHalInterface> *device) {
+    audio_hw_device_t *dev;
+    status_t rc = load_audio_interface(name, &dev);
+    if (rc == OK) {
+        //  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/4.0/DeviceHalLocal.cpp
+        *device = new DeviceHalLocal(dev);
+    }
+    return rc;
+}
+
+
+static status_t load_audio_interface(const char *if_name, audio_hw_device_t **dev)
+{
+    const hw_module_t *mod;
+    int rc;
+
+    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &mod);
+    if (rc) {
+        ALOGE("%s couldn't load audio hw module %s.%s (%s)", __func__, AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));
+        goto out;
+    }
+    rc = audio_hw_device_open(mod, dev);
+    if (rc) {
+        ALOGE("%s couldn't open audio hw device in %s.%s (%s)", __func__, AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));
+        goto out;
+    }
+    if ((*dev)->common.version < AUDIO_DEVICE_API_VERSION_MIN) {
+        ALOGE("%s wrong audio hw device version %04x", __func__, (*dev)->common.version);
+        rc = BAD_VALUE;
+        audio_hw_device_close(*dev);
+        goto out;
+    }
+    return OK;
+
+out:
+    *dev = NULL;
+    return rc;
+}
+
+
diff --git a/android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalHidl.cpp b/android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalHidl.cpp
new file mode 100644
index 0000000..98d20dc
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalHidl.cpp
@@ -0,0 +1,19 @@
+//@ /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/EffectsFactoryHalInterface.cpp
+sp<EffectsFactoryHalInterface> EffectsFactoryHalInterface::create() {
+    if (hardware::audio::effect::V4_0::IEffectsFactory::getService() != nullptr) {
+        return new V4_0::EffectsFactoryHalHidl();
+    }
+    if (hardware::audio::effect::V2_0::IEffectsFactory::getService() != nullptr) {
+        return new EffectsFactoryHalHidl();
+    }
+    return nullptr;
+}
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/media/libaudiohal/4.0/EffectsFactoryHalHidl.cpp
+EffectsFactoryHalHidl::EffectsFactoryHalHidl() : ConversionHelperHidl("EffectsFactory") {
+    mEffectsFactory = IEffectsFactory::getService();
+    if (mEffectsFactory == 0) {
+        ALOGE("Failed to obtain IEffectsFactory service, terminating process.");
+        exit(1);
+    }
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalInterface.cpp b/android-auto-9-notes/media/audioserver/AudioFlinger/EffectsFactoryHalInterface.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioGain.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioGain.cpp
new file mode 100644
index 0000000..cc75779
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioGain.cpp
@@ -0,0 +1,7 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/src/AudioGain.cpp
+AudioGain::AudioGain(int index, bool useInChannelMask)
+{
+    mIndex = index;
+    mUseInChannelMask = useInChannelMask;
+    memset(&mGain, 0, sizeof(struct audio_gain));
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyConfig.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyConfig.cpp
new file mode 100644
index 0000000..ce11d09
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyConfig.cpp
@@ -0,0 +1,104 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/include/AudioPolicyConfig.h
+
+/***
+ * @ frameworks/av/services/audiopolicy/common/managerdefinitions/include/HwModule.h
+ * HwModule 
+*/  
+class HwModuleCollection : public Vector<sp<HwModule> >{
+
+}
+
+/***
+ * @    /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/include/DeviceDescriptor.h
+ * 
+ */
+class DeviceVector : public SortedVector<sp<DeviceDescriptor> >{
+
+}
+
+
+
+/**
+ * 
+ * HwModuleCollection @ frameworks/av/services/audiopolicy/common/managerdefinitions/include/HwModule.h
+ * 
+ * 
+ */
+AudioPolicyConfig::AudioPolicyConfig(HwModuleCollection &hwModules,
+                    DeviceVector &availableOutputDevices,
+                    DeviceVector &availableInputDevices,
+                    sp<DeviceDescriptor> &defaultOutputDevices,
+                    VolumeCurvesCollection *volumes = nullptr)
+    : mHwModules(hwModules),
+        mAvailableOutputDevices(availableOutputDevices),
+        mAvailableInputDevices(availableInputDevices),
+        mDefaultOutputDevices(defaultOutputDevices),
+        mVolumeCurves(volumes),
+        mIsSpeakerDrcEnabled(false)
+{
+
+}
+
+/**
+ * 
+ * 这里是在解析 audio_policy_configuration_car.xml 文件中 
+ * <module name="primary" halVersion="2.0">
+    //  这里直接解析加入到 AudioPolicyConfig 中，通过接口 addAvailableDevice
+    <attachedDevices>
+        <item>bus0_media_out</item>
+        <item>bus1_system_sound_out</item>
+        <item>Built-In Mic</item>
+    </attachedDevices>
+
+   </module>
+ * 这里  去当前解析的 module 中查找 对应item 属性 的 DeviceDescriptor
+ * 通过 HwModule 以下 getDeclaredDevices().getDeviceFromTagName
+ */
+void addAvailableDevice(const sp<DeviceDescriptor> &availableDevice)
+{
+    if (audio_is_output_device(availableDevice->type())) {
+        mAvailableOutputDevices.add(availableDevice);
+    } else if (audio_is_input_device(availableDevice->type())) {
+        mAvailableInputDevices.add(availableDevice);
+    }
+}
+
+
+
+/***
+ * <module name="primary" halVersion="2.0">
+    <defaultOutputDevice>bus0_media_out</defaultOutputDevice>
+   </module>
+ * 注意这里永远只有有一个默认值，这里  去当前解析的 module 中查找 对应defaultOutputDevice 属性 的 DeviceDescriptor 
+ * 通过 HwModule 以下 getDeclaredDevices().getDeviceFromTagName
+ */
+void setDefaultOutputDevice(const sp<DeviceDescriptor> &defaultDevice)
+{
+    mDefaultOutputDevices = defaultDevice;
+}
+
+
+void setVolumes(const VolumeCurvesCollection &volumes)
+{
+    if (mVolumeCurves != nullptr) {
+        *mVolumeCurves = volumes;
+    }
+}
+
+void setHwModules(const HwModuleCollection &hwModules)
+{
+    mHwModules = hwModules;
+}
+
+/***
+ * <audioPolicyConfiguration version="1.0" xmlns:xi="http://www.w3.org/2001/XInclude">
+ *  <globalConfiguration speaker_drc_enabled="true"/>
+ * ......
+ * </audioPolicyConfiguration>
+ * 
+ */
+
+void setSpeakerDrcEnabled(bool isSpeakerDrcEnabled)
+{
+    mIsSpeakerDrcEnabled = isSpeakerDrcEnabled;
+}
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyManager.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyManager.cpp
index 7159208..c58ae26 100644
--- a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyManager.cpp
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyManager.cpp
@@ -66,6 +66,9 @@ static status_t deserializeAudioPolicyXmlConfig(AudioPolicyConfig &config) {
     std::vector<const char*> fileNames;
     status_t ret;
 
+    /**
+     * 默认这里属性都为空，所以默认为false值
+     */
     if (property_get_bool("ro.bluetooth.a2dp_offload.supported", false) && property_get_bool("persist.bluetooth.a2dp_offload.disabled", false)) {
         // A2DP offload supported but disabled: try to use special XML file
         //  #define AUDIO_POLICY_A2DP_OFFLOAD_DISABLED_XML_CONFIG_FILE_NAME "audio_policy_configuration_a2dp_offload_disabled.xml"
@@ -75,6 +78,12 @@ static status_t deserializeAudioPolicyXmlConfig(AudioPolicyConfig &config) {
     //  #define AUDIO_POLICY_XML_CONFIG_FILE_NAME "audio_policy_configuration.xml"
     fileNames.push_back(AUDIO_POLICY_XML_CONFIG_FILE_NAME);
 
+    /**
+     * 
+     * 
+     * 根据系统目前只有 /vendor/etc/audio_policy_configuration.xml(系统路径)
+     * 源码路径 device/autolink/imx8q/autolink_8q/audio_policy_configuration.xml
+     */
     for (const char* fileName : fileNames) {
         for (int i = 0; i < kConfigLocationListSize; i++) {
             //  @frameworks/av/services/audiopolicy/common/managerdefinitions/src/Serializer.cpp
@@ -96,6 +105,9 @@ static status_t deserializeAudioPolicyXmlConfig(AudioPolicyConfig &config) {
 #endif
 
 status_t AudioPolicyManager::initialize() {
+    /**
+     * true,空实现没有实际作用
+     */
     mVolumeCurves->initializeVolumeCurves(getConfig().isSpeakerDrcEnabled());
 
     //  @ frameworks/av/services/audiopolicy/engineconfigurable/src/EngineInstance.cpp
@@ -119,7 +131,15 @@ status_t AudioPolicyManager::initialize() {
         LOG_FATAL("Policy engine not initialized(err=%d)", status);
         return status;
     }
-
+    /***
+     * 
+     *  <attachedDevices>
+                <item>bus0_media_out</item>
+                <item>bus1_system_sound_out</item>
+                <item>Built-In Mic</item>
+            </attachedDevices>
+     * 
+     */
     // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices
     // open all output streams needed to access attached devices
     audio_devices_t outputDeviceTypes = mAvailableOutputDevices.types();
@@ -195,8 +215,7 @@ status_t AudioPolicyManager::initialize() {
         // mAvailableInputDevices list
         for (const auto& inProfile : hwModule->getInputProfiles()) {
             if (!inProfile->canOpenNewIo()) {
-                ALOGE("Invalid Input profile max open count %u for profile %s",
-                      inProfile->maxOpenCount, inProfile->getTagName().c_str());
+                ALOGE("Invalid Input profile max open count %u for profile %s",inProfile->maxOpenCount, inProfile->getTagName().c_str());
                 continue;
             }
             if (!inProfile->hasSupportedDevices()) {
@@ -293,4 +312,21 @@ status_t AudioPolicyManager::initialize() {
 
     updateDevicesAndOutputs();
     return status;
+}
+
+
+
+
+
+uint32_t AudioPolicyManager::getStrategyForAttr(const audio_attributes_t *attr) {
+    // flags to strategy mapping
+    if ((attr->flags & AUDIO_FLAG_BEACON) == AUDIO_FLAG_BEACON) {
+        return (uint32_t) STRATEGY_TRANSMITTED_THROUGH_SPEAKER;
+    }
+    if ((attr->flags & AUDIO_FLAG_AUDIBILITY_ENFORCED) == AUDIO_FLAG_AUDIBILITY_ENFORCED) {
+        return (uint32_t) STRATEGY_ENFORCED_AUDIBLE;
+    }
+    // usage to strategy mapping
+    //mEngine 在  status_t AudioPolicyManager::initialize() 
+    return static_cast<uint32_t>(mEngine->getStrategyForUsage(attr->usage));
 }
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyService.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyService.cpp
index 625887f..e64d67d 100644
--- a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyService.cpp
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioPolicyService.cpp
@@ -22,7 +22,7 @@ void AudioPolicyService::onFirstRef()
         mOutputCommandThread = new AudioCommandThread(String8("ApmOutput"), this);
 
         /***
-         * 
+         * 提供给 AudioPolicyManager 回调接口
          */ 
         mAudioPolicyClient = new AudioPolicyClient(this);
         //  @   /work/workcodes/aosp-p9.x-auto-alpha/frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cpp
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioProfile.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioProfile.cpp
new file mode 100644
index 0000000..62ad264
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioProfile.cpp
@@ -0,0 +1,24 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/include/AudioProfile.h
+
+AudioProfile(audio_format_t format,
+                audio_channel_mask_t channelMasks,
+                uint32_t samplingRate) :
+    mName(String8("")),
+    mFormat(format)
+{
+    mChannelMasks.add(channelMasks);
+    mSamplingRates.add(samplingRate);
+}
+
+/***
+typedef SortedVector<uint32_t> SampleRateVector;
+typedef SortedVector<audio_channel_mask_t> ChannelsVector;
+ */
+AudioProfile(audio_format_t format,
+                const ChannelsVector &channelMasks,
+                const SampleRateVector &samplingRateCollection) :
+    mName(String8("")),
+    mFormat(format),
+    mChannelMasks(channelMasks),
+    mSamplingRates(samplingRateCollection)
+{}
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioRoute.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioRoute.cpp
new file mode 100644
index 0000000..538bb64
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/AudioRoute.cpp
@@ -0,0 +1,37 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/src/AudioRoute.cpp
+
+/*
+
+<routes>
+    <route type="mix" sink="bus0_media_out" sources="mixport_bus0_media_out"/>
+    <route type="mix" sink="bus1_system_sound_out" sources="mixport_bus1_system_sound_out"/>
+    <route type="mix" sink="primary input" sources="Built-In Mic"/>
+</routes>
+
+
+
+
+typedef enum {
+    AUDIO_ROUTE_MUX = 0,
+    AUDIO_ROUTE_MIX = 1
+} audio_route_type_t;
+
+*/
+explicit AudioRoute(audio_route_type_t type) : mType(type) {}
+
+/***
+ * 
+ * 通过 sink 属性值 去对应的 HwModule 中通过 findPortByTagName 方法 找到所有匹配的 AudioPort 压入 AudioPortVector，
+ * 再 通过 setSources 函数设置
+ * 
+ * 
+ */
+
+void setSources(const AudioPortVector &sources) { mSources = sources; }
+/***
+ * 
+ * 通过 sink 属性值 去对应的 HwModule 中通过 findPortByTagName 方法 找到所有匹配的 AudioPort 压入 AudioPortVector，
+ * 再 通过 setSink 函数设置
+ */
+//      sp<AudioPort> mSink;
+void setSink(const sp<AudioPort> &sink) { mSink = sink; }
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/DeviceDescriptor.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/DeviceDescriptor.cpp
new file mode 100644
index 0000000..6c198b8
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/DeviceDescriptor.cpp
@@ -0,0 +1,26 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/src/DeviceDescriptor.cpp
+/*
+ * 
+ * 该类对应标签属性 devicePorts ，和 mixPort 有这同样的子标签 profile 和 gain
+ */
+class DeviceDescriptor : public AudioPort, public AudioPortConfig{}
+
+
+DeviceDescriptor::DeviceDescriptor(audio_devices_t type, const String8 &tagName) :
+    AudioPort(String8(""), AUDIO_PORT_TYPE_DEVICE, audio_is_output_device(type) ? AUDIO_PORT_ROLE_SINK : AUDIO_PORT_ROLE_SOURCE),
+    mAddress(""), mTagName(tagName), mDeviceType(type), mId(0)
+{
+    if (type == AUDIO_DEVICE_IN_REMOTE_SUBMIX || type == AUDIO_DEVICE_OUT_REMOTE_SUBMIX ) {
+        mAddress = String8("0");
+    }
+}
+
+
+
+/***
+ * @    /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/include/AudioPort.h
+ */
+void addRoute(const sp<AudioRoute> &route) { mRoutes.add(route); }
+
+
+
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/Engine.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/Engine.cpp
new file mode 100644
index 0000000..ec3cb66
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/Engine.cpp
@@ -0,0 +1,26 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp
+
+class ManagerInterfaceImpl : public AudioPolicyManagerInterface{} mManagerInterface；
+
+
+Engine::Engine()
+    : mManagerInterface(this),
+      mPhoneState(AUDIO_MODE_NORMAL),
+      mApmObserver(NULL)
+{
+    // AUDIO_POLICY_FORCE_USE_CNT @ system/media/audio/include/system/audio_policy.h
+    for (int i = 0; i < AUDIO_POLICY_FORCE_USE_CNT; i++) {
+        mForceUse[i] = AUDIO_POLICY_FORCE_NONE;
+    }
+}
+
+void Engine::setObserver(AudioPolicyManagerObserver *observer)
+{
+    ALOG_ASSERT(observer != NULL, "Invalid Audio Policy Manager observer");
+    mApmObserver = observer;
+}
+
+status_t Engine::initCheck()
+{
+    return (mApmObserver != NULL) ?  NO_ERROR : NO_INIT;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/EngineInstance.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/EngineInstance.cpp
new file mode 100644
index 0000000..aaf236f
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/EngineInstance.cpp
@@ -0,0 +1,19 @@
+
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/enginedefault/src/EngineInstance.cpp
+EngineInstance::EngineInstance()
+{
+}
+
+EngineInstance *EngineInstance::getInstance()
+{
+    static EngineInstance instance;
+    return &instance;
+}
+
+
+template <>
+AudioPolicyManagerInterface *EngineInstance::queryInterface() const
+{
+    return getEngine()->queryInterface<AudioPolicyManagerInterface>();
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/HwModule.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/HwModule.cpp
new file mode 100644
index 0000000..5f0f6d8
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/HwModule.cpp
@@ -0,0 +1,229 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/src/HwModule.cpp
+
+
+ /***
+ * 每一个 module 对应类为 HwModule 
+ */
+ <!-- Primary Audio HAL -->
+<module name="primary" halVersion="2.0">
+    //  这里直接解析加入到 AudioPolicyConfig 中，通过接口 addAvailableDevice
+    <attachedDevices>
+        <item>bus0_media_out</item>
+        <item>bus1_system_sound_out</item>
+        <item>Built-In Mic</item>
+    </attachedDevices>
+    <defaultOutputDevice>bus0_media_out</defaultOutputDevice>
+    <mixPorts>
+        /***
+         * 每一个 mixPort 对应类为 IOProfile 
+         */
+        <mixPort name="mixport_bus0_media_out" role="source"
+                flags="AUDIO_OUTPUT_FLAG_PRIMARY">
+            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
+                        samplingRates="48000"
+                        channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
+        </mixPort>
+        <mixPort name="mixport_bus1_system_sound_out" role="source"
+                flags="AUDIO_OUTPUT_FLAG_PRIMARY">
+            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
+                        samplingRates="48000"
+                        channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
+        </mixPort>
+        <mixPort name="primary input" role="sink">
+            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
+                        samplingRates="8000,11025,16000,22050,24000,32000,44100,48000"
+                        channelMasks="AUDIO_CHANNEL_IN_MONO,AUDIO_CHANNEL_IN_STEREO"/>
+        </mixPort>
+
+    </mixPorts>
+    <devicePorts>
+        <devicePort tagName="bus0_media_out" role="sink" type="AUDIO_DEVICE_OUT_BUS"
+                address="bus0_media_out">
+            <gains>
+                <gain name="" mode="AUDIO_GAIN_MODE_JOINT"
+                        minValueMB="-3200" maxValueMB="600" defaultValueMB="0" stepValueMB="100"/>
+            </gains>
+        </devicePort>
+        <devicePort tagName="bus1_system_sound_out" role="sink" type="AUDIO_DEVICE_OUT_BUS"
+                address="bus1_system_sound_out">
+            <gains>
+                <gain name="" mode="AUDIO_GAIN_MODE_JOINT"
+                        minValueMB="-3200" maxValueMB="600" defaultValueMB="0" stepValueMB="100"/>
+            </gains>
+        </devicePort>
+
+        <devicePort tagName="Built-In Mic" type="AUDIO_DEVICE_IN_BUILTIN_MIC" role="source">
+        </devicePort>
+    </devicePorts>
+    <!-- route declaration, i.e. list all available sources for a given sink -->
+    <routes>
+        <route type="mix" sink="bus0_media_out" sources="mixport_bus0_media_out"/>
+        <route type="mix" sink="bus1_system_sound_out" sources="mixport_bus1_system_sound_out"/>
+        <route type="mix" sink="primary input" sources="Built-In Mic"/>
+    </routes>
+
+</module>
+ ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+/**
+ * <module name="primary" halVersion="2.0">
+ * ......
+ * </module>
+ */
+HwModule::HwModule(const char *name, uint32_t halVersionMajor, uint32_t halVersionMinor)
+    : mName(String8(name)),
+      mHandle(AUDIO_MODULE_HANDLE_NONE)
+{
+    setHalVersion(halVersionMajor, halVersionMinor);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/**
+ * 
+ * 
+ * <mixPorts>
+        <mixPort name="usb_accessory output" role="source">
+            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT"
+                     samplingRates="44100" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
+        </mixPort>
+        <mixPort name="usb_device output" role="source"/>
+        <mixPort name="usb_device input" role="sink"/>
+    </mixPorts>    
+ * 这里是 解析 mixPorts 孩子标签 mixPort，每一个 mixPort 对应一个类 IOProfile
+ * 
+ */
+void HwModule::setProfiles(const IOProfileCollection &profiles)
+{
+    for (size_t i = 0; i < profiles.size(); i++) {
+        addProfile(profiles[i]);
+    }
+}
+
+status_t HwModule::addProfile(const sp<IOProfile> &profile)
+{
+    switch (profile->getRole()) {
+    case AUDIO_PORT_ROLE_SOURCE:
+        return addOutputProfile(profile);
+    case AUDIO_PORT_ROLE_SINK:
+        return addInputProfile(profile);
+    case AUDIO_PORT_ROLE_NONE:
+        return BAD_VALUE;
+    }
+    return BAD_VALUE;
+}
+
+status_t HwModule::addOutputProfile(const sp<IOProfile> &profile)
+{
+    profile->attach(this);
+    mOutputProfiles.add(profile);
+    mPorts.add(profile);
+    return NO_ERROR;
+}
+
+status_t HwModule::addInputProfile(const sp<IOProfile> &profile)
+{
+    profile->attach(this);
+    mInputProfiles.add(profile);
+    mPorts.add(profile);
+    return NO_ERROR;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/***
+ * 
+ * <devicePorts>
+                <devicePort tagName="bus0_media_out" role="sink" type="AUDIO_DEVICE_OUT_BUS"
+                        address="bus0_media_out">
+                    <gains>
+                        <gain name="" mode="AUDIO_GAIN_MODE_JOINT"
+                                minValueMB="-3200" maxValueMB="600" defaultValueMB="0" stepValueMB="100"/>
+                    </gains>
+    </devicePort>
+    <devicePort tagName="bus1_system_sound_out" role="sink" type="AUDIO_DEVICE_OUT_BUS"
+            address="bus1_system_sound_out">
+        <gains>
+            <gain name="" mode="AUDIO_GAIN_MODE_JOINT"
+                    minValueMB="-3200" maxValueMB="600" defaultValueMB="0" stepValueMB="100"/>
+        </gains>
+    </devicePort>
+
+    <devicePort tagName="Built-In Mic" type="AUDIO_DEVICE_IN_BUILTIN_MIC" role="source">
+    </devicePort>
+</devicePorts>
+ * 
+ */
+void HwModule::setDeclaredDevices(const DeviceVector &devices)
+{
+    mDeclaredDevices = devices;
+    for (size_t i = 0; i < devices.size(); i++) {
+        mPorts.add(devices[i]);
+    }
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+void HwModule::setRoutes(const AudioRouteVector &routes)
+{
+    mRoutes = routes;
+    // Now updating the streams (aka IOProfile until now) supported devices
+    refreshSupportedDevices();
+}
+
+void HwModule::refreshSupportedDevices()
+{
+    // Now updating the streams (aka IOProfile until now) supported devices
+    for (const auto& stream : mInputProfiles) {
+        DeviceVector sourceDevices;
+        for (const auto& route : stream->getRoutes()) {
+            sp<AudioPort> sink = route->getSink();
+            if (sink == 0 || stream != sink) {
+                ALOGE("%s: Invalid route attached to input stream", __FUNCTION__);
+                continue;
+            }
+            DeviceVector sourceDevicesForRoute = getRouteSourceDevices(route);
+            if (sourceDevicesForRoute.isEmpty()) {
+                ALOGE("%s: invalid source devices for %s", __FUNCTION__, stream->getName().string());
+                continue;
+            }
+            sourceDevices.add(sourceDevicesForRoute);
+        }
+        if (sourceDevices.isEmpty()) {
+            ALOGE("%s: invalid source devices for %s", __FUNCTION__, stream->getName().string());
+            continue;
+        }
+        stream->setSupportedDevices(sourceDevices);
+    }
+
+    for (const auto& stream : mOutputProfiles) {
+        DeviceVector sinkDevices;
+        for (const auto& route : stream->getRoutes()) {
+            sp<AudioPort> source = route->getSources().findByTagName(stream->getTagName());
+            if (source == 0 || stream != source) {
+                ALOGE("%s: Invalid route attached to output stream", __FUNCTION__);
+                continue;
+            }
+            sp<DeviceDescriptor> sinkDevice = getRouteSinkDevice(route);
+            if (sinkDevice == 0) {
+                ALOGE("%s: invalid sink device for %s", __FUNCTION__, stream->getName().string());
+                continue;
+            }
+            sinkDevices.add(sinkDevice);
+        }
+        stream->setSupportedDevices(sinkDevices);
+    }
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+sp<AudioPort> findPortByTagName(const String8 &tagName) const
+{
+    return mPorts.findByTagName(tagName);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+const OutputProfileCollection &getOutputProfiles() const { return mOutputProfiles; }
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/IOProfile.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/IOProfile.cpp
new file mode 100644
index 0000000..318262f
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/IOProfile.cpp
@@ -0,0 +1,42 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/src/IOProfile.cpp
+class IOProfile : public AudioPort{
+
+}
+
+/***
+ * 
+ *  <mixPorts>
+        <mixPort name="mixport_bus0_media_out" role="source" flags="AUDIO_OUTPUT_FLAG_PRIMARY">
+            <profile name="" format="AUDIO_FORMAT_PCM_16_BIT" samplingRates="48000" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
+        </mixPort>
+    </mixPorts>
+ * 
+ * audio_port_role_t 对应属性  role ，可能值为 "source" 或者为 “sink”
+ * 
+ *    
+ */
+IOProfile(const String8 &name, audio_port_role_t role)
+        : AudioPort(name, AUDIO_PORT_TYPE_MIX, role),
+          maxOpenCount((role == AUDIO_PORT_ROLE_SOURCE) ? 1 : 0),           //  
+          curOpenCount(0),
+          maxActiveCount(1),
+          curActiveCount(0) {}
+
+
+/***
+ * @    /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/include/AudioProfile.h
+ * class AudioProfileVector : public Vector<sp<AudioProfile> >{}
+ */
+void setAudioProfiles(const AudioProfileVector &profiles) {
+    mProfiles = profiles; 
+}
+
+
+void setGains(const AudioGainCollection &gains) {
+     mGains = gains;
+}
+
+/***
+ * @    /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/include/AudioPort.h
+ */
+void addRoute(const sp<AudioRoute> &route) { mRoutes.add(route); }
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/PolicySerializer.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/PolicySerializer.cpp
index 7364711..aa37a42 100644
--- a/android-auto-9-notes/media/audioserver/AudioPolicyService/PolicySerializer.cpp
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/PolicySerializer.cpp
@@ -119,7 +119,6 @@ static status_t deserializeCollection(_xmlDoc *doc, const _xmlNode *cur,typename
 
 
 //status_t ModuleTraits::deserialize(xmlDocPtr doc, const xmlNode *root, sp<HwModule> &module,PtrSerializingCtx ctx)
-
 status_t ModuleTraits::deserialize(xmlDocPtr doc, const xmlNode *root, PtrElement &module,PtrSerializingCtx ctx)
 {
     string name = getXmlAttribute(root, Attributes::name);//	const char ModuleTraits::Attributes::name[] = "name";
@@ -156,11 +155,12 @@ status_t ModuleTraits::deserialize(xmlDocPtr doc, const xmlNode *root, PtrElemen
 
     /***
      * 
-            <attachedDevices>
-                <item>Speaker</item>
-                <item>Built-In Mic</item>
-            </attachedDevices>
-            <defaultOutputDevice>Speaker</defaultOutputDevice>
+       <attachedDevices>
+            <item>bus0_media_out</item>
+            <item>bus1_system_sound_out</item>
+            <item>Built-In Mic</item>
+        </attachedDevices>
+        <defaultOutputDevice>bus0_media_out</defaultOutputDevice>
 
      * */
     const xmlNode *children = root->xmlChildrenNode;
@@ -280,13 +280,30 @@ status_t MixPortTraits::deserialize(_xmlDoc *doc, const _xmlNode *child, PtrElem
     return NO_ERROR;
 }
 
-
+/***
+ * 
+ * 
+    <mixPort name="primary output" role="source" flags="AUDIO_OUTPUT_FLAG_PRIMARY">
+    //  这里 name 属性没有用，可以为空
+        <profile name="" format="AUDIO_FORMAT_PCM_16_BIT" samplingRates="48000" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
+    </mixPort>
+ * 
+ */
 status_t AudioProfileTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root, PtrElement &profile,PtrSerializingCtx /*serializingContext*/)
 {
-    string samplingRates = getXmlAttribute(root, Attributes::samplingRates);
-    string format = getXmlAttribute(root, Attributes::format);
-    string channels = getXmlAttribute(root, Attributes::channelMasks);
+    //  const char AudioProfileTraits::Attributes::name[] = "name"; 没有作用
 
+    string samplingRates = getXmlAttribute(root, Attributes::samplingRates);//  const char AudioProfileTraits::Attributes::samplingRates[] = "samplingRates";
+    string format = getXmlAttribute(root, Attributes::format);  //  const char AudioProfileTraits::Attributes::format[] = "format";
+    string channels = getXmlAttribute(root, Attributes::channelMasks);//const char AudioProfileTraits::Attributes::channelMasks[] = "channelMasks";
+    /***
+     * frameworks/av/services/audiopolicy/common/include/policy.h:21:static const audio_format_t gDynamicFormat = AUDIO_FORMAT_DEFAULT;
+     * 
+     * formatFromString 将字符串转为 枚举类型
+     * channelMasksFromString 用“，”分解字符串，
+     * samplingRatesFromString 用“，”分解字符串，
+     */
+    //  AudioProfile 
     profile = new Element(formatFromString(format, gDynamicFormat),channelMasksFromString(channels, ","),samplingRatesFromString(samplingRates, ","));
 
     profile->setDynamicFormat(profile->getFormat() == gDynamicFormat);
@@ -296,19 +313,31 @@ status_t AudioProfileTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root,
     return NO_ERROR;
 }
 
-
+/***
+const char AudioGainTraits::Attributes::mode[] = "mode";
+const char AudioGainTraits::Attributes::channelMask[] = "channel_mask";
+const char AudioGainTraits::Attributes::minValueMB[] = "minValueMB";
+const char AudioGainTraits::Attributes::maxValueMB[] = "maxValueMB";
+const char AudioGainTraits::Attributes::defaultValueMB[] = "defaultValueMB";
+const char AudioGainTraits::Attributes::stepValueMB[] = "stepValueMB";
+const char AudioGainTraits::Attributes::minRampMs[] = "minRampMs";
+const char AudioGainTraits::Attributes::maxRampMs[] = "maxRampMs";
+ */
 
 status_t AudioGainTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root, PtrElement &gain,PtrSerializingCtx /*serializingContext*/)
 {
     static uint32_t index = 0;
+    /**
+     * AudioGain 
+     */
     gain = new Element(index++, true);
 
-    string mode = getXmlAttribute(root, Attributes::mode);
+    string mode = getXmlAttribute(root, Attributes::mode);  //  const char AudioGainTraits::Attributes::mode[] = "mode";
     if (!mode.empty()) {
         gain->setMode(GainModeConverter::maskFromString(mode));
     }
 
-    string channelsLiteral = getXmlAttribute(root, Attributes::channelMask);
+    string channelsLiteral = getXmlAttribute(root, Attributes::channelMask); // const char AudioGainTraits::Attributes::channelMask[] = "channel_mask";
     if (!channelsLiteral.empty()) {
         gain->setChannelMask(channelMaskFromString(channelsLiteral));
     }
@@ -359,6 +388,35 @@ status_t AudioGainTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root, Ptr
 }
 
 
+
+
+/**
+ <devicePorts>
+    <devicePort tagName="USB Host Out" type="AUDIO_DEVICE_OUT_USB_ACCESSORY" role="sink">
+        <profile name="" format="AUDIO_FORMAT_PCM_16_BIT" samplingRates="44100" channelMasks="AUDIO_CHANNEL_OUT_STEREO"/>
+    </devicePort>
+    <devicePort tagName="USB Device Out" type="AUDIO_DEVICE_OUT_USB_DEVICE" role="sink"/>
+    <devicePort tagName="USB Headset Out" type="AUDIO_DEVICE_OUT_USB_HEADSET" role="sink"/>
+    <devicePort tagName="USB Device In" type="AUDIO_DEVICE_IN_USB_DEVICE" role="source"/>
+    <devicePort tagName="USB Headset In" type="AUDIO_DEVICE_IN_USB_HEADSET" role="source"/>
+</devicePorts>
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+const char *const DevicePortTraits::tag = "devicePort";
+const char *const DevicePortTraits::collectionTag = "devicePorts";
+
+const char DevicePortTraits::Attributes::tagName[] = "tagName";
+const char DevicePortTraits::Attributes::type[] = "type";
+const char DevicePortTraits::Attributes::role[] = "role";
+const char DevicePortTraits::Attributes::address[] = "address";
+const char DevicePortTraits::Attributes::roleSource[] = "source";
+ */
+
 status_t DevicePortTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, PtrElement &deviceDesc,PtrSerializingCtx /*serializingContext*/)
 {
     string name = getXmlAttribute(root, Attributes::tagName);
@@ -388,7 +446,7 @@ status_t DevicePortTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, PtrEl
         ALOGW("%s: bad type %08x", __FUNCTION__, type);
         return BAD_VALUE;
     }
-    deviceDesc = new Element(type, String8(name.c_str()));
+    deviceDesc = new Element(type, String8(name.c_str())); // DeviceDescriptor
 
     string address = getXmlAttribute(root, Attributes::address);
     if (!address.empty()) {
@@ -413,7 +471,34 @@ status_t DevicePortTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, PtrEl
     return NO_ERROR;
 }
 
+/*
+<routes>
+    <route type="mix" sink="USB Host Out"
+            sources="usb_accessory output"/>
+    <route type="mix" sink="USB Device Out"
+            sources="usb_device output"/>
+    <route type="mix" sink="USB Headset Out"
+            sources="usb_device output"/>
+    <route type="mix" sink="usb_device input"
+            sources="USB Device In,USB Headset In"/>
+</routes>
+
+
+
+
+const char *const RouteTraits::tag = "route";
+const char *const RouteTraits::collectionTag = "routes";
 
+const char RouteTraits::Attributes::type[] = "type";
+const char RouteTraits::Attributes::typeMix[] = "mix";
+const char RouteTraits::Attributes::sink[] = "sink";
+const char RouteTraits::Attributes::sources[] = "sources";
+
+
+
+
+这里 PtrSerializingCtx 为 HwModule
+ */
 
 
 status_t RouteTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root, PtrElement &element,PtrSerializingCtx ctx)
@@ -426,7 +511,7 @@ status_t RouteTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root, PtrElem
     audio_route_type_t routeType = (type == Attributes::typeMix) ? AUDIO_ROUTE_MIX : AUDIO_ROUTE_MUX;
 
     ALOGV("%s: %s %s=%s", __FUNCTION__, tag, Attributes::type, type.c_str());
-    element = new Element(routeType);
+    element = new Element(routeType);  //   AudioRoute 
 
     string sinkAttr = getXmlAttribute(root, Attributes::sink);
     if (sinkAttr.empty()) {
@@ -509,43 +594,18 @@ status_t RouteTraits::deserialize(_xmlDoc /*doc*/, const _xmlNode *root, PtrElem
 
     </volumes>
 
+
+
+const char *const VolumeTraits::tag = "volume";
+const char *const VolumeTraits::collectionTag = "volumes";
+const char *const VolumeTraits::volumePointTag = "point";
+
+const char VolumeTraits::Attributes::stream[] = "stream";
+const char VolumeTraits::Attributes::deviceCategory[] = "deviceCategory";
+const char VolumeTraits::Attributes::reference[] = "ref";
+
+
 */
-template <class Trait>
-static status_t deserializeCollection(_xmlDoc *doc, const _xmlNode *cur,typename Trait::Collection &collection,typename Trait::PtrSerializingCtx serializingContext)
-{
-    const xmlNode *root = cur->xmlChildrenNode;
-    while (root != NULL) {
-    	//	const char *const VolumeTraits::collectionTag = "volumes";
-    	//	const char *const VolumeTraits::tag = "volume";
-        if (xmlStrcmp(root->name, (const xmlChar *)Trait::collectionTag) &&  xmlStrcmp(root->name, (const xmlChar *)Trait::tag)) {
-            root = root->next;
-            continue;
-        }
-        const xmlNode *child = root;
-        if (!xmlStrcmp(child->name, (const xmlChar *)Trait::collectionTag)) {//	const char *const VolumeTraits::collectionTag = "volumes";
-            child = child->xmlChildrenNode;
-        }
-        while (child != NULL) {
-            if (!xmlStrcmp(child->name, (const xmlChar *)Trait::tag)) {//	const char *const VolumeTraits::tag = "volume";
-                typename Trait::PtrElement element; // typename VolumeTraits::sp<VolumeCurve> element;
-                //status_t status = VolumeTraits::deserialize(doc, child, element, serializingContext);  
-                status_t status = Trait::deserialize(doc, child, element, serializingContext);
-                if (status != NO_ERROR) {
-                    return status;
-                }
-                if (collection.add(element) < 0) {
-                    ALOGE("%s: could not add element to %s collection", __FUNCTION__,Trait::collectionTag);
-                }
-            }
-            child = child->next;
-        }
-        if (!xmlStrcmp(root->name, (const xmlChar *)Trait::tag)) {
-            return NO_ERROR;
-        }
-        root = root->next;
-    }
-    return NO_ERROR;
-}
 
 //status_t VolumeTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, sp<VolumeCurve> &element, PtrSerializingCtx /*serializingContext*/)
 status_t VolumeTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, PtrElement &element, PtrSerializingCtx /*serializingContext*/)
@@ -582,7 +642,7 @@ status_t VolumeTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, PtrElemen
     }
 
     // element = new VolumeCurve(deviceCategory, streamType); 
-    element = new Element(deviceCategory, streamType);
+    element = new Element(deviceCategory, streamType); //   VolumeCurve
 
     const xmlNode *child = referenceName.empty() ? root->xmlChildrenNode : ref->xmlChildrenNode;
     while (child != NULL) {
@@ -606,6 +666,28 @@ status_t VolumeTraits::deserialize(_xmlDoc *doc, const _xmlNode *root, PtrElemen
     return NO_ERROR;
 }
 
+//  getReference<VolumeTraits>(root->parent, ref, referenceName);
+static void getReference(const _xmlNode *root, const _xmlNode *&refNode, const string &refName)
+{
+    const _xmlNode *col = root;
+    while (col != NULL) {
+        if (!xmlStrcmp(col->name, (const xmlChar *)Trait::collectionTag)) { //  const char *const VolumeTraits::collectionTag = "volumes";
+            const xmlNode *cur = col->children;
+            while (cur != NULL) {
+                if ((!xmlStrcmp(cur->name, (const xmlChar *)gReferenceElementName))) { //static const char *const gReferenceElementName = "reference";
+                    string name = getXmlAttribute(cur, gReferenceAttributeName);    //  static const char *const gReferenceAttributeName = "name";
+                    if (refName == name) {
+                        refNode = cur;
+                        return;
+                    }
+                }
+                cur = cur->next;
+            }
+        }
+        col = col->next;
+    }
+    return;
+}
 
 
 
diff --git a/android-auto-9-notes/media/audioserver/AudioPolicyService/VolumeCurve.cpp b/android-auto-9-notes/media/audioserver/AudioPolicyService/VolumeCurve.cpp
new file mode 100644
index 0000000..44c6229
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/AudioPolicyService/VolumeCurve.cpp
@@ -0,0 +1,53 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/av/services/audiopolicy/common/managerdefinitions/src/VolumeCurve.cpp
+
+
+/***
+ * 
+ <volumes>
+    <volume stream="AUDIO_STREAM_VOICE_CALL" deviceCategory="DEVICE_CATEGORY_HEADSET">
+        <point>0,-4200</point>
+        <point>33,-2800</point>
+        <point>66,-1400</point>
+        <point>100,0</point>
+    </volume>
+    <volume stream="AUDIO_STREAM_VOICE_CALL" deviceCategory="DEVICE_CATEGORY_EXT_MEDIA"  ref="DEFAULT_MEDIA_VOLUME_CURVE"/>
+    
+
+    <reference name="DEFAULT_MEDIA_VOLUME_CURVE">
+    <!-- Default Media reference Volume Curve -->
+        <point>1,-5800</point>
+        <point>20,-4000</point>
+        <point>60,-1700</point>
+        <point>100,0</point>
+    </reference>
+ </volumes>
+ * 
+ * 
+ * 
+ */
+
+VolumeCurve(device_category device, audio_stream_type_t stream) :
+        mDeviceCategory(device), mStreamType(stream) {}
+
+
+/***
+ struct CurvePoint
+{
+    CurvePoint() {}
+    CurvePoint(int index, int attenuationInMb) :
+        mIndex(index), mAttenuationInMb(attenuationInMb) {}
+    uint32_t mIndex;
+    int mAttenuationInMb;
+};
+ * 
+ * 
+ * SortedVector<CurvePoint> mCurvePoints;
+ */
+
+void add(const CurvePoint &point) { mCurvePoints.add(point); }
+
+
+
+
+
+
diff --git a/android-auto-9-notes/media/audioserver/audioserver.txt b/android-auto-9-notes/media/audioserver/audioserver.txt
new file mode 100644
index 0000000..3159df9
--- /dev/null
+++ b/android-auto-9-notes/media/audioserver/audioserver.txt
@@ -0,0 +1,7 @@
+./media/libaudioclient/include/media/IAudioFlinger.h:56:    class CreateTrackInput : public Parcelable {
+./media/libaudioclient/include/media/IAudioFlinger.h:133:    class CreateTrackOutput : public Parcelable {
+
+
+
+
+//  frameworks/av/services/audiopolicy/config/audio_policy_configuration.xml
\ No newline at end of file
diff --git a/android-auto-9-notes/media/audioserver/main_audioserver.cpp b/android-auto-9-notes/media/audioserver/main_audioserver.cpp
index d8d86da..5a5765b 100644
--- a/android-auto-9-notes/media/audioserver/main_audioserver.cpp
+++ b/android-auto-9-notes/media/audioserver/main_audioserver.cpp
@@ -108,6 +108,9 @@ int main(int argc __unused, char **argv)
         // This prevents a client from misusing AAudioService when it is not supported.
 
         //  @frameworks/av/media/libaaudio/src/utility/AAudioUtilities.h:245:   #define AAUDIO_PROP_MMAP_POLICY           "aaudio.mmap_policy"
+        /**
+         * 目前这个属性为空
+         */
         aaudio_policy_t mmapPolicy = property_get_int32(AAUDIO_PROP_MMAP_POLICY,AAUDIO_POLICY_NEVER);
         if (mmapPolicy == AAUDIO_POLICY_AUTO || mmapPolicy == AAUDIO_POLICY_ALWAYS) {
             AAudioService::instantiate();
diff --git a/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueue.cpp b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueue.cpp
new file mode 100644
index 0000000..12ddea2
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueue.cpp
@@ -0,0 +1,21 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/BufferQueue.cpp
+/**
+ * 在 BufferLayer 中调用
+ */ 
+void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,sp<IGraphicBufferConsumer>* outConsumer,
+                bool consumerIsSurfaceFlinger /*=true*/) {
+    LOG_ALWAYS_FATAL_IF(outProducer == NULL,"BufferQueue: outProducer must not be NULL");
+    LOG_ALWAYS_FATAL_IF(outConsumer == NULL,"BufferQueue: outConsumer must not be NULL");
+
+    sp<BufferQueueCore> core(new BufferQueueCore());
+    LOG_ALWAYS_FATAL_IF(core == NULL,"BufferQueue: failed to create BufferQueueCore");
+
+    sp<IGraphicBufferProducer> producer(new BufferQueueProducer(core, consumerIsSurfaceFlinger /*=true*/));
+    LOG_ALWAYS_FATAL_IF(producer == NULL,"BufferQueue: failed to create BufferQueueProducer");
+
+    sp<IGraphicBufferConsumer> consumer(new BufferQueueConsumer(core));
+    LOG_ALWAYS_FATAL_IF(consumer == NULL,"BufferQueue: failed to create BufferQueueConsumer");
+
+    *outProducer = producer;
+    *outConsumer = consumer;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueConsumer.cpp b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueConsumer.cpp
new file mode 100644
index 0000000..384933b
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueConsumer.cpp
@@ -0,0 +1,11 @@
+class BufferQueueConsumer : public BnGraphicBufferConsumer {
+
+}
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/BufferQueueConsumer.cpp
+BufferQueueConsumer::BufferQueueConsumer(const sp<BufferQueueCore>& core) :
+    mCore(core),
+    mSlots(core->mSlots),
+    mConsumerName() {
+
+}
diff --git a/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueCore.cpp b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueCore.cpp
new file mode 100644
index 0000000..fa8cff2
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueCore.cpp
@@ -0,0 +1,73 @@
+  
+class BufferQueueCore : public virtual RefBase {
+
+}
+
+//  @ /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/BufferQueueCore.cpp
+BufferQueueCore::BufferQueueCore() :
+    mMutex(),
+    mIsAbandoned(false),
+    mConsumerControlledByApp(false),
+    mConsumerName(getUniqueName()),
+    mConsumerListener(),
+    mConsumerUsageBits(0),
+    mConsumerIsProtected(false),
+    mConnectedApi(NO_CONNECTED_API),
+    mLinkedToDeath(),
+    mConnectedProducerListener(),
+    //  BufferQueueDefs::SlotsType mSlots;      // BufferSlot @ /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/include/gui/BufferQueueDefs.h 
+    mSlots(),           
+    mQueue(),
+    mFreeSlots(),
+    mFreeBuffers(),
+    mUnusedSlots(),
+    mActiveBuffers(),
+    mDequeueCondition(),
+    mDequeueBufferCannotBlock(false),
+    mDefaultBufferFormat(PIXEL_FORMAT_RGBA_8888),
+    mDefaultWidth(1),
+    mDefaultHeight(1),
+    mDefaultBufferDataSpace(HAL_DATASPACE_UNKNOWN),
+    mMaxBufferCount(BufferQueueDefs::NUM_BUFFER_SLOTS),
+    mMaxAcquiredBufferCount(1),
+    mMaxDequeuedBufferCount(1),
+    mBufferHasBeenQueued(false),
+    mFrameCounter(0),
+    mTransformHint(0),
+    mIsAllocating(false),
+    mIsAllocatingCondition(),
+    mAllowAllocation(true),
+    mBufferAge(0),
+    mGenerationNumber(0),
+    mAsyncMode(false),
+    mSharedBufferMode(false),
+    mAutoRefresh(false),
+    mSharedBufferSlot(INVALID_BUFFER_SLOT),
+    mSharedBufferCache(Rect::INVALID_RECT, 0, NATIVE_WINDOW_SCALING_MODE_FREEZE,HAL_DATASPACE_UNKNOWN),
+    mLastQueuedSlot(INVALID_BUFFER_SLOT),
+    mUniqueId(getUniqueId())
+{
+    int numStartingBuffers = getMaxBufferCountLocked();
+    for (int s = 0; s < numStartingBuffers; s++) {
+        mFreeSlots.insert(s);
+    }
+    /**
+     * /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/include/ui/BufferQueueDefs.h
+     * static constexpr int NUM_BUFFER_SLOTS = 64;
+    */
+    for (int s = numStartingBuffers; s < BufferQueueDefs::NUM_BUFFER_SLOTS; s++) {
+        mUnusedSlots.push_front(s);
+    }
+}
+
+
+int BufferQueueCore::getMaxBufferCountLocked() const {
+
+    // maxBufferCount = 1 + 1 + 0
+    int maxBufferCount = mMaxAcquiredBufferCount + mMaxDequeuedBufferCount + ((mAsyncMode || mDequeueBufferCannotBlock) ? 1 : 0);
+
+    // limit maxBufferCount by mMaxBufferCount always
+    maxBufferCount = std::min(mMaxBufferCount, maxBufferCount);
+
+    return maxBufferCount;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueProducer.cpp b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueProducer.cpp
new file mode 100644
index 0000000..01df667
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/BufferQueue/BufferQueueProducer.cpp
@@ -0,0 +1,20 @@
+class BufferQueueProducer : public BnGraphicBufferProducer, private IBinder::DeathRecipient {
+
+}
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/BufferQueueProducer.cpp
+BufferQueueProducer::BufferQueueProducer(const sp<BufferQueueCore>& core,bool consumerIsSurfaceFlinger /*=true*/) :
+    mCore(core),
+    mSlots(core->mSlots),
+    mConsumerName(),
+    mStickyTransform(0),
+    mConsumerIsSurfaceFlinger(consumerIsSurfaceFlinger),
+    mLastQueueBufferFence(Fence::NO_FENCE),
+    mLastQueuedTransform(0),
+    mCallbackMutex(),
+    mNextCallbackTicket(0),
+    mCurrentCallbackTicket(0),
+    mCallbackCondition(),
+    mDequeueTimeout(-1) {
+
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/Client.cpp b/android-auto-9-notes/media/surfaceflinger/Client.cpp
new file mode 100644
index 0000000..c3dcbd2
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/Client.cpp
@@ -0,0 +1,83 @@
+class ISurfaceComposerClient : public IInterface {
+public:
+    DECLARE_META_INTERFACE(SurfaceComposerClient)
+
+    // flags for createSurface()
+    enum { // (keep in sync with Surface.java)
+        eHidden = 0x00000004,
+        eDestroyBackbuffer = 0x00000020,
+        eSecure = 0x00000080,
+        eNonPremultiplied = 0x00000100,
+        eOpaque = 0x00000400,
+        eProtectedByApp = 0x00000800,
+        eProtectedByDRM = 0x00001000,
+        eCursorWindow = 0x00002000,
+
+        eFXSurfaceNormal = 0x00000000,
+        eFXSurfaceColor = 0x00020000,
+        eFXSurfaceMask = 0x000F0000,
+    };
+
+    /*
+     * Requires ACCESS_SURFACE_FLINGER permission
+     */
+    virtual status_t createSurface(const String8& name, uint32_t w, uint32_t h, PixelFormat format,
+                                   uint32_t flags, const sp<IBinder>& parent, int32_t windowType,
+                                   int32_t ownerUid, sp<IBinder>* handle,
+                                   sp<IGraphicBufferProducer>* gbp) = 0;
+
+    /*
+     * Requires ACCESS_SURFACE_FLINGER permission
+     */
+    virtual status_t destroySurface(const sp<IBinder>& handle) = 0;
+
+    /*
+     * Requires ACCESS_SURFACE_FLINGER permission
+     */
+    virtual status_t clearLayerFrameStats(const sp<IBinder>& handle) const = 0;
+
+    /*
+     * Requires ACCESS_SURFACE_FLINGER permission
+     */
+    virtual status_t getLayerFrameStats(const sp<IBinder>& handle, FrameStats* outStats) const = 0;
+};
+
+
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/Client.cpp
+Client::Client(const sp<SurfaceFlinger>& flinger) : Client(flinger, nullptr)
+{
+}
+
+Client::Client(const sp<SurfaceFlinger>& flinger, const sp<Layer>& parentLayer)
+    : mFlinger(flinger), mParentLayer(parentLayer)
+{
+}
+
+status_t Client::createSurface(
+        const String8& name,
+        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
+        const sp<IBinder>& parentHandle, int32_t windowType, int32_t ownerUid,
+        sp<IBinder>* handle,
+        sp<IGraphicBufferProducer>* gbp)
+{
+    sp<Layer> parent = nullptr;
+    if (parentHandle != nullptr) {
+        auto layerHandle = reinterpret_cast<Layer::Handle*>(parentHandle.get());
+        parent = layerHandle->owner.promote();
+        if (parent == nullptr) {
+            return NAME_NOT_FOUND;
+        }
+    }
+    if (parent == nullptr) {
+        bool parentDied;
+        parent = getParentLayer(&parentDied);
+        // If we had a parent, but it died, we've lost all
+        // our capabilities.
+        if (parentDied) {
+            return NAME_NOT_FOUND;
+        }
+    }
+
+    return mFlinger->createLayer(name, this, w, h, format, flags, windowType,ownerUid, handle, gbp, &parent);
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/ComposerService.cpp b/android-auto-9-notes/media/surfaceflinger/ComposerService.cpp
new file mode 100644
index 0000000..7b6993b
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/ComposerService.cpp
@@ -0,0 +1,30 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/SurfaceComposerClient.cpp
+ComposerService::ComposerService()
+: Singleton<ComposerService>() {
+    Mutex::Autolock _l(mLock);
+    connectLocked();
+}
+
+
+
+void ComposerService::connectLocked() {
+    const String16 name("SurfaceFlinger");
+    while (getService(name, &mComposerService) != NO_ERROR) {
+        usleep(250000);
+    }
+    assert(mComposerService != NULL);
+
+    // Create the death listener.
+    class DeathObserver : public IBinder::DeathRecipient {
+        ComposerService& mComposerService;
+        virtual void binderDied(const wp<IBinder>& who) {
+            ALOGW("ComposerService remote (surfaceflinger) died [%p]",who.unsafe_get());
+            mComposerService.composerServiceDied();
+        }
+     public:
+        explicit DeathObserver(ComposerService& mgr) : mComposerService(mgr) { }
+    };
+
+    mDeathObserver = new DeathObserver(*const_cast<ComposerService*>(this));
+    IInterface::asBinder(mComposerService)->linkToDeath(mDeathObserver);
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/DispSync.cpp b/android-auto-9-notes/media/surfaceflinger/DispSync.cpp
new file mode 100644
index 0000000..bab149d
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/DispSync.cpp
@@ -0,0 +1,46 @@
+
+class DispSync {
+public:
+    class Callback {
+    public:
+        virtual ~Callback(){};
+        virtual void onDispSyncEvent(nsecs_t when) = 0;
+    };
+
+
+}
+
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/DispSync.cpp
+DispSync::DispSync(const char* name) : mName(name), mRefreshSkipCount(0), mThread(new DispSyncThread(name)) {
+
+}
+
+
+void DispSync::init(bool hasSyncFramework, int64_t dispSyncPresentTimeOffset) {
+    mIgnorePresentFences = !hasSyncFramework;
+    mPresentTimeOffset = dispSyncPresentTimeOffset;
+    mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
+
+    // set DispSync to SCHED_FIFO to minimize jitter
+    struct sched_param param = {0};
+    param.sched_priority = 2;
+    if (sched_setscheduler(mThread->getTid(), SCHED_FIFO, &param) != 0) {
+        ALOGE("Couldn't set SCHED_FIFO for DispSyncThread");
+    }
+
+    reset();
+    beginResync();
+
+    if (kTraceDetailedInfo) {   //  kTraceDetailedInfo = false;
+        // If we're not getting present fences then the ZeroPhaseTracer
+        // would prevent HW vsync event from ever being turned off.
+        // Even if we're just ignoring the fences, the zero-phase tracing is
+        // not needed because any time there is an event registered we will
+        // turn on the HW vsync events.
+        if (!mIgnorePresentFences && kEnableZeroPhaseTracer) {
+            mZeroPhaseTracer = std::make_unique<ZeroPhaseTracer>();
+            addEventListener("ZeroPhaseTracer", 0, mZeroPhaseTracer.get());
+        }
+    }
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/DispSyncSource.cpp b/android-auto-9-notes/media/surfaceflinger/DispSyncSource.cpp
new file mode 100644
index 0000000..ddf6525
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/DispSyncSource.cpp
@@ -0,0 +1,22 @@
+
+
+
+class DispSyncSource final : public VSyncSource, private DispSync::Callback {
+
+}
+
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+DispSyncSource::DispSyncSource(DispSync* dispSync, nsecs_t phaseOffset, bool traceVsync,const char* name) :
+        mName(name),
+        mValue(0),
+        mTraceVsync(traceVsync),
+        mVsyncOnLabel(String8::format("VsyncOn-%s", name)),
+        mVsyncEventLabel(String8::format("VSYNC-%s", name)),
+        mDispSync(dispSync),
+        mCallbackMutex(),
+        mVsyncMutex(),
+        mPhaseOffset(phaseOffset),
+        mEnabled(false) {}
+
+
diff --git a/android-auto-9-notes/media/surfaceflinger/Layer/BufferLayer.cpp b/android-auto-9-notes/media/surfaceflinger/Layer/BufferLayer.cpp
new file mode 100644
index 0000000..aaf5713
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/Layer/BufferLayer.cpp
@@ -0,0 +1,74 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/BufferLayer.cpp
+BufferLayer::BufferLayer(SurfaceFlinger* flinger, const sp<Client>& client, const String8& name,uint32_t w, uint32_t h, uint32_t flags)
+      : Layer(flinger, client, name, w, h, flags),
+        mConsumer(nullptr),
+        mTextureName(UINT32_MAX),
+        mFormat(PIXEL_FORMAT_NONE),
+        mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
+        mBufferLatched(false),
+        mPreviousFrameNumber(0),
+        mUpdateTexImageFailed(false),
+        mRefreshPending(false) {
+    ALOGV("Creating Layer %s", name.string());
+
+    mTextureName = mFlinger->getNewTexture();
+    mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);
+
+    if (flags & ISurfaceComposerClient::eNonPremultiplied) mPremultipliedAlpha = false;
+
+    mCurrentState.requested = mCurrentState.active;
+
+    // drawing state & current state are identical
+    mDrawingState = mCurrentState;
+}
+
+void BufferLayer::onFirstRef() {
+    Layer::onFirstRef();
+
+    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use
+    sp<IGraphicBufferProducer> producer;
+    sp<IGraphicBufferConsumer> consumer;
+    BufferQueue::createBufferQueue(&producer, &consumer, true);
+    mProducer = new MonitoredProducer(producer, mFlinger, this);
+    {
+        // Grab the SF state lock during this since it's the only safe way to access RenderEngine
+        Mutex::Autolock lock(mFlinger->mStateLock);
+        mConsumer = new BufferLayerConsumer(consumer, mFlinger->getRenderEngine(), mTextureName,
+                                            this);
+    }
+    mConsumer->setConsumerUsageBits(getEffectiveUsage(0));
+    mConsumer->setContentsChangedListener(this);
+    mConsumer->setName(mName);
+
+    if (mFlinger->isLayerTripleBufferingDisabled()) {
+        mProducer->setMaxDequeuedBufferCount(2);
+    }
+
+    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
+    updateTransformHint(hw);
+}
+
+
+status_t BufferLayer::setBuffers(uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) {
+    //  
+    uint32_t const maxSurfaceDims = min(mFlinger->getMaxTextureSize(), mFlinger->getMaxViewportDims());
+
+    // never allow a surface larger than what our underlying GL implementation
+    // can handle.
+    if ((uint32_t(w) > maxSurfaceDims) || (uint32_t(h) > maxSurfaceDims)) {
+        ALOGE("dimensions too large %u x %u", uint32_t(w), uint32_t(h));
+        return BAD_VALUE;
+    }
+
+    mFormat = format;
+
+    mPotentialCursor = (flags & ISurfaceComposerClient::eCursorWindow) ? true : false;
+    mProtectedByApp = (flags & ISurfaceComposerClient::eProtectedByApp) ? true : false;
+    mCurrentOpacity = getOpacityForFormat(format);
+
+    mConsumer->setDefaultBufferSize(w, h);
+    mConsumer->setDefaultBufferFormat(format);
+    mConsumer->setConsumerUsageBits(getEffectiveUsage(0));
+
+    return NO_ERROR;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/Layer/Layer.cpp b/android-auto-9-notes/media/surfaceflinger/Layer/Layer.cpp
new file mode 100644
index 0000000..f37429a
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/Layer/Layer.cpp
@@ -0,0 +1,84 @@
+
+
+
+//    @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/Layer.cpp
+Layer::Layer(SurfaceFlinger* flinger, const sp<Client>& client, const String8& name, uint32_t w,uint32_t h, uint32_t flags)
+      : contentDirty(false),
+        sequence(uint32_t(android_atomic_inc(&sSequence))),
+        mFlinger(flinger),
+        mPremultipliedAlpha(true),
+        mName(name),
+        mTransactionFlags(0),
+        mPendingStateMutex(),
+        mPendingStates(),
+        mQueuedFrames(0),
+        mSidebandStreamChanged(false),
+        mActiveBufferSlot(BufferQueue::INVALID_BUFFER_SLOT),
+        mCurrentTransform(0),
+        mOverrideScalingMode(-1),
+        mCurrentOpacity(true),
+        mCurrentFrameNumber(0),
+        mFrameLatencyNeeded(false),
+        mFiltering(false),
+        mNeedsFiltering(false),
+        mProtectedByApp(false),
+        mClientRef(client),
+        mPotentialCursor(false),
+        mQueueItemLock(),
+        mQueueItemCondition(),
+        mQueueItems(),
+        mLastFrameNumberReceived(0),
+        mAutoRefresh(false),
+        mFreezeGeometryUpdates(false),
+        mCurrentChildren(LayerVector::StateSet::Current),
+        mDrawingChildren(LayerVector::StateSet::Drawing) {
+    mCurrentCrop.makeInvalid();
+
+    uint32_t layerFlags = 0;
+    if (flags & ISurfaceComposerClient::eHidden) layerFlags |= layer_state_t::eLayerHidden;
+    if (flags & ISurfaceComposerClient::eOpaque) layerFlags |= layer_state_t::eLayerOpaque;
+    if (flags & ISurfaceComposerClient::eSecure) layerFlags |= layer_state_t::eLayerSecure;
+
+    mName = name;
+    mTransactionName = String8("TX - ") + mName;
+
+    mCurrentState.active.w = w;
+    mCurrentState.active.h = h;
+    mCurrentState.flags = layerFlags;
+    mCurrentState.active.transform.set(0, 0);
+    mCurrentState.crop.makeInvalid();
+    mCurrentState.finalCrop.makeInvalid();
+    mCurrentState.requestedFinalCrop = mCurrentState.finalCrop;
+    mCurrentState.requestedCrop = mCurrentState.crop;
+    mCurrentState.z = 0;
+    mCurrentState.color.a = 1.0f;
+    mCurrentState.layerStack = 0;
+    mCurrentState.sequence = 0;
+    mCurrentState.requested = mCurrentState.active;
+    mCurrentState.appId = 0;
+    mCurrentState.type = 0;
+
+    // drawing state & current state are identical
+    mDrawingState = mCurrentState;
+
+    CompositorTiming compositorTiming;
+    flinger->getCompositorTiming(&compositorTiming);
+    mFrameEventHistory.initializeCompositorTiming(compositorTiming);
+}
+
+void Layer::onFirstRef() NO_THREAD_SAFETY_ANALYSIS {
+    if (!isCreatedFromMainThread()) {
+        // Grab the SF state lock during this since it's the only way to safely access HWC
+        mFlinger->mStateLock.lock();
+    }
+
+    const auto& hwc = mFlinger->getHwComposer();
+    const auto& activeConfig = hwc.getActiveConfig(HWC_DISPLAY_PRIMARY);
+    nsecs_t displayPeriod = activeConfig->getVsyncPeriod();
+    mFrameTracker.setDisplayRefreshPeriod(displayPeriod);
+
+    if (!isCreatedFromMainThread()) {
+        mFlinger->mStateLock.unlock();
+    }
+}
+
diff --git a/android-auto-9-notes/media/surfaceflinger/Layer/Texture.cpp b/android-auto-9-notes/media/surfaceflinger/Layer/Texture.cpp
new file mode 100644
index 0000000..6d915f0
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/Layer/Texture.cpp
@@ -0,0 +1,9 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/RenderEngine/Texture.cpp
+Texture::Texture(): mTextureName(0), mTextureTarget(TEXTURE_2D), mWidth(0), mHeight(0), mFiltering(false) {
+    
+}
+
+void Texture::init(Target textureTarget, uint32_t textureName) {
+    mTextureName = textureName;
+    mTextureTarget = textureTarget;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/MessageQueue.cpp b/android-auto-9-notes/media/surfaceflinger/MessageQueue.cpp
new file mode 100644
index 0000000..0f04b89
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/MessageQueue.cpp
@@ -0,0 +1,94 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/MessageQueue.cpp
+
+void MessageQueue::init(const sp<SurfaceFlinger>& flinger) {
+    mFlinger = flinger;
+    mLooper = new Looper(true);
+    mHandler = new Handler(*this);
+}
+
+
+void MessageQueue::setEventThread(android::EventThread* eventThread) {
+    if (mEventThread == eventThread) {
+        return;
+    }
+
+    if (mEventTube.getFd() >= 0) {
+        mLooper->removeFd(mEventTube.getFd());
+    }
+
+    mEventThread = eventThread;
+    mEvents = eventThread->createEventConnection();
+    mEvents->stealReceiveChannel(&mEventTube);
+    mLooper->addFd(mEventTube.getFd(), 0, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,this);
+}
+
+
+sp<BnDisplayEventConnection> EventThread::createEventConnection() const {
+    return new Connection(const_cast<EventThread*>(this));
+}
+
+int MessageQueue::cb_eventReceiver(int fd, int events, void* data) {
+    MessageQueue* queue = reinterpret_cast<MessageQueue*>(data);
+    return queue->eventReceiver(fd, events);
+}
+
+int MessageQueue::eventReceiver(int /*fd*/, int /*events*/) {
+    ssize_t n;
+    DisplayEventReceiver::Event buffer[8];
+    while ((n = DisplayEventReceiver::getEvents(&mEventTube, buffer, 8)) > 0) {
+        for (int i = 0; i < n; i++) {
+            if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) {
+                mHandler->dispatchInvalidate();
+                break;
+            }
+        }
+    }
+    return 1;
+}
+
+
+
+void MessageQueue::Handler::dispatchRefresh() {
+    if ((android_atomic_or(eventMaskRefresh, &mEventMask) & eventMaskRefresh) == 0) {
+        mQueue.mLooper->sendMessage(this, Message(MessageQueue::REFRESH));
+    }
+}
+
+void MessageQueue::Handler::dispatchInvalidate() {
+    if ((android_atomic_or(eventMaskInvalidate, &mEventMask) & eventMaskInvalidate) == 0) {
+        mQueue.mLooper->sendMessage(this, Message(MessageQueue::INVALIDATE));
+    }
+}
+
+
+void MessageQueue::Handler::handleMessage(const Message& message) {
+    switch (message.what) {
+        case INVALIDATE:
+            android_atomic_and(~eventMaskInvalidate, &mEventMask);
+            mQueue.mFlinger->onMessageReceived(message.what);
+            break;
+        case REFRESH:
+            android_atomic_and(~eventMaskRefresh, &mEventMask);
+            mQueue.mFlinger->onMessageReceived(message.what);
+            break;
+    }
+}
+
+
+
+
+
+EventThread::Connection::Connection(EventThread* eventThread) 
+    : count(-1), mEventThread(eventThread), mChannel(gui::BitTube::DefaultSize) {
+
+}
+
+void EventThread::Connection::onFirstRef() {
+    // NOTE: mEventThread doesn't hold a strong reference on us
+    mEventThread->registerDisplayEventConnection(this);
+}
+
+status_t EventThread::Connection::stealReceiveChannel(gui::BitTube* outChannel) {
+    outChannel->setReceiveFd(mChannel.moveReceiveFd());
+    return NO_ERROR;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp b/android-auto-9-notes/media/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
new file mode 100644
index 0000000..8b6a53a
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
@@ -0,0 +1,52 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
+GLES20RenderEngine::GLES20RenderEngine(uint32_t featureFlags): RenderEngine(featureFlags),
+        mVpWidth(0),
+        mVpHeight(0),
+        mPlatformHasWideColor((featureFlags & WIDE_COLOR_SUPPORT) != 0) {
+    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &mMaxTextureSize);
+    glGetIntegerv(GL_MAX_VIEWPORT_DIMS, mMaxViewportDims);
+
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
+    glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    const uint16_t protTexData[] = {0};
+    glGenTextures(1, &mProtectedTexName);
+    glBindTexture(GL_TEXTURE_2D, mProtectedTexName);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, protTexData);
+
+    // mColorBlindnessCorrection = M;
+
+    if (mPlatformHasWideColor) {
+        ColorSpace srgb(ColorSpace::sRGB());
+        ColorSpace displayP3(ColorSpace::DisplayP3());
+        ColorSpace bt2020(ColorSpace::BT2020());
+
+        // Compute sRGB to Display P3 transform matrix.
+        // NOTE: For now, we are limiting output wide color space support to
+        // Display-P3 only.
+        mSrgbToDisplayP3 = mat4(ColorSpaceConnector(srgb, displayP3).getTransform());
+
+        // Compute Display P3 to sRGB transform matrix.
+        mDisplayP3ToSrgb = mat4(ColorSpaceConnector(displayP3, srgb).getTransform());
+
+        // no chromatic adaptation needed since all color spaces use D65 for their white points.
+        mSrgbToXyz = srgb.getRGBtoXYZ();
+        mDisplayP3ToXyz = displayP3.getRGBtoXYZ();
+        mBt2020ToXyz = bt2020.getRGBtoXYZ();
+        mXyzToSrgb = mat4(srgb.getXYZtoRGB());
+        mXyzToDisplayP3 = mat4(displayP3.getXYZtoRGB());
+        mXyzToBt2020 = mat4(bt2020.getXYZtoRGB());
+    }
+}
+
+size_t GLES20RenderEngine::getMaxTextureSize() const {
+    return mMaxTextureSize;
+}
+
+size_t GLES20RenderEngine::getMaxViewportDims() const {
+    return mMaxViewportDims[0] < mMaxViewportDims[1] ? mMaxViewportDims[0] : mMaxViewportDims[1];
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/RenderEngine/GLExtensions.cpp b/android-auto-9-notes/media/surfaceflinger/RenderEngine/GLExtensions.cpp
new file mode 100644
index 0000000..74eb9d1
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/RenderEngine/GLExtensions.cpp
@@ -0,0 +1,67 @@
+
+class GLExtensions : public Singleton<GLExtensions> {
+
+}
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/RenderEngine/GLExtensions.cpp
+void GLExtensions::initWithEGLStrings(char const* eglVersion, char const* eglExtensions) {
+    mEGLVersion = eglVersion;
+    mEGLExtensions = eglExtensions;
+    mEGLExtensionList = parseExtensionString(mEGLExtensions);
+
+    // EGL_ANDROIDX_no_config_context is an experimental extension with no
+    // written specification. It will be replaced by something more formal.
+    // SurfaceFlinger is using it to allow a single EGLContext to render to
+    // both a 16-bit primary display framebuffer and a 32-bit virtual display
+    // framebuffer.
+    //
+    // EGL_KHR_no_config_context is official extension to allow creating a
+    // context that works with any surface of a display.
+    if (hasEGLExtension("EGL_ANDROIDX_no_config_context") ||
+        hasEGLExtension("EGL_KHR_no_config_context")) {
+        mHasNoConfigContext = true;
+    }
+
+    if (hasEGLExtension("EGL_ANDROID_native_fence_sync")) {
+        mHasNativeFenceSync = true;
+    }
+    if (hasEGLExtension("EGL_KHR_fence_sync")) {
+        mHasFenceSync = true;
+    }
+    if (hasEGLExtension("EGL_KHR_wait_sync")) {
+        mHasWaitSync = true;
+    }
+
+    if (hasEGLExtension("EGL_ANDROID_image_crop")) {
+        mHasImageCrop = true;
+    }
+    if (hasEGLExtension("EGL_EXT_protected_content")) {
+        mHasProtectedContent = true;
+    }
+    if (hasEGLExtension("EGL_IMG_context_priority")) {
+        mHasContextPriority = true;
+    }
+}
+
+SortedVector<String8> GLExtensions::parseExtensionString(char const* extensions) {
+    SortedVector<String8> list;
+
+    char const* curr = extensions;
+    char const* head = curr;
+    do {
+        head = strchr(curr, ' ');
+        String8 s(curr, head ? head - curr : strlen(curr));
+        if (s.length()) {
+            list.add(s);
+        }
+        curr = head + 1;
+    } while (head);
+
+    return list;
+}
+
+
+bool GLExtensions::hasEGLExtension(char const* extension) const {
+    const String8 s(extension);
+    return mEGLExtensionList.indexOf(s) >= 0;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/RenderEngine/RenderEngine.cpp b/android-auto-9-notes/media/surfaceflinger/RenderEngine/RenderEngine.cpp
new file mode 100644
index 0000000..90c0eb6
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/RenderEngine/RenderEngine.cpp
@@ -0,0 +1,123 @@
+
+/****
+ * 封装了 RenderEngine opengl 初始化接口
+ * 这里是在 SurfaceFlinger::init() 中调用
+ */
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp
+std::unique_ptr<RenderEngine> ::create(int hwcFormat, uint32_t featureFlags) {
+    // initialize EGL for the default display
+    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (!eglInitialize(display, nullptr, nullptr)) {
+        LOG_ALWAYS_FATAL("failed to initialize EGL");
+    }
+
+    //  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/RenderEngine/GLExtensions.cpp
+    GLExtensions& extensions = GLExtensions::getInstance();
+    extensions.initWithEGLStrings(eglQueryStringImplementationANDROID(display, EGL_VERSION),
+                                  eglQueryStringImplementationANDROID(display, EGL_EXTENSIONS));
+
+    // The code assumes that ES2 or later is available if this extension is
+    // supported.
+    EGLConfig config = EGL_NO_CONFIG;
+    if (!extensions.hasNoConfigContext()) {
+        config = chooseEglConfig(display, hwcFormat, /*logConfig*/ true);
+    }
+
+    EGLint renderableType = 0;
+    if (config == EGL_NO_CONFIG) {
+        renderableType = EGL_OPENGL_ES2_BIT;
+    } else if (!eglGetConfigAttrib(display, config, EGL_RENDERABLE_TYPE, &renderableType)) {
+        LOG_ALWAYS_FATAL("can't query EGLConfig RENDERABLE_TYPE");
+    }
+    EGLint contextClientVersion = 0;
+    if (renderableType & EGL_OPENGL_ES2_BIT) {
+        contextClientVersion = 2;
+    } else if (renderableType & EGL_OPENGL_ES_BIT) {
+        contextClientVersion = 1;
+    } else {
+        LOG_ALWAYS_FATAL("no supported EGL_RENDERABLE_TYPEs");
+    }
+
+    std::vector<EGLint> contextAttributes;
+    contextAttributes.reserve(6);
+    contextAttributes.push_back(EGL_CONTEXT_CLIENT_VERSION);
+    contextAttributes.push_back(contextClientVersion);
+    bool useContextPriority = overrideUseContextPriorityFromConfig(extensions.hasContextPriority());
+    if (useContextPriority) {
+        contextAttributes.push_back(EGL_CONTEXT_PRIORITY_LEVEL_IMG);
+        contextAttributes.push_back(EGL_CONTEXT_PRIORITY_HIGH_IMG);
+    }
+    contextAttributes.push_back(EGL_NONE);
+
+    EGLContext ctxt = eglCreateContext(display, config, nullptr, contextAttributes.data());
+
+    // if can't create a GL context, we can only abort.
+    LOG_ALWAYS_FATAL_IF(ctxt == EGL_NO_CONTEXT, "EGLContext creation failed");
+
+    // now figure out what version of GL did we actually get
+    // NOTE: a dummy surface is not needed if KHR_create_context is supported
+
+    EGLConfig dummyConfig = config;
+    if (dummyConfig == EGL_NO_CONFIG) {
+        dummyConfig = chooseEglConfig(display, hwcFormat, /*logConfig*/ true);
+    }
+    EGLint attribs[] = {EGL_WIDTH, 1, EGL_HEIGHT, 1, EGL_NONE, EGL_NONE};
+    EGLSurface dummy = eglCreatePbufferSurface(display, dummyConfig, attribs);
+    LOG_ALWAYS_FATAL_IF(dummy == EGL_NO_SURFACE, "can't create dummy pbuffer");
+    EGLBoolean success = eglMakeCurrent(display, dummy, dummy, ctxt);
+    LOG_ALWAYS_FATAL_IF(!success, "can't make dummy pbuffer current");
+
+    extensions.initWithGLStrings(glGetString(GL_VENDOR), glGetString(GL_RENDERER),glGetString(GL_VERSION), glGetString(GL_EXTENSIONS));
+
+    GlesVersion version = parseGlesVersion(extensions.getVersion());
+
+    // initialize the renderer while GL is current
+
+    std::unique_ptr<RenderEngine> engine;
+    switch (version) {
+        case GLES_VERSION_1_0:
+        case GLES_VERSION_1_1:
+            LOG_ALWAYS_FATAL("SurfaceFlinger requires OpenGL ES 2.0 minimum to run.");
+            break;
+        case GLES_VERSION_2_0:
+        case GLES_VERSION_3_0:
+            engine = std::make_unique<GLES20RenderEngine>(featureFlags);
+            break;
+    }
+    engine->setEGLHandles(display, config, ctxt);
+
+    ALOGI("OpenGL ES informations:");
+    ALOGI("vendor    : %s", extensions.getVendor());
+    ALOGI("renderer  : %s", extensions.getRenderer());
+    ALOGI("version   : %s", extensions.getVersion());
+    ALOGI("extensions: %s", extensions.getExtensions());
+    ALOGI("GL_MAX_TEXTURE_SIZE = %zu", engine->getMaxTextureSize());
+    ALOGI("GL_MAX_VIEWPORT_DIMS = %zu", engine->getMaxViewportDims());
+
+    eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroySurface(display, dummy);
+
+    return engine;
+}
+
+RenderEngine::RenderEngine(uint32_t featureFlags)
+      : mEGLDisplay(EGL_NO_DISPLAY),
+        mEGLConfig(nullptr),
+        mEGLContext(EGL_NO_CONTEXT),
+        mFeatureFlags(featureFlags) {
+}
+
+void RenderEngine::setEGLHandles(EGLDisplay display, EGLConfig config, EGLContext ctxt) {
+    mEGLDisplay = display;
+    mEGLConfig = config;
+    mEGLContext = ctxt;
+}
+
+
+/**
+ * 生成纹理 
+ */
+void RenderEngine::genTextures(size_t count, uint32_t* names) {
+    glGenTextures(count, names);
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/RenderEngine/Surface.cpp b/android-auto-9-notes/media/surfaceflinger/RenderEngine/Surface.cpp
new file mode 100644
index 0000000..7355b57
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/RenderEngine/Surface.cpp
@@ -0,0 +1,8 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/RenderEngine/Surface.cpp
+Surface::Surface(const RenderEngine& engine)
+      : mEGLDisplay(engine.getEGLDisplay()), mEGLConfig(engine.getEGLConfig()) {
+    // RE does not assume any config when EGL_KHR_no_config_context is supported
+    if (mEGLConfig == EGL_NO_CONFIG_KHR) {
+        mEGLConfig = RenderEngine::chooseEglConfig(mEGLDisplay, PIXEL_FORMAT_RGBA_8888, false);
+    }
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/SurfaceComposerClient.cpp b/android-auto-9-notes/media/surfaceflinger/SurfaceComposerClient.cpp
new file mode 100644
index 0000000..0b47247
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/SurfaceComposerClient.cpp
@@ -0,0 +1,82 @@
+class SurfaceComposerClient : public RefBase{
+
+}
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/SurfaceComposerClient.cpp
+SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT)
+{
+}
+
+SurfaceComposerClient::SurfaceComposerClient(const sp<IGraphicBufferProducer>& root) : mStatus(NO_INIT), mParent(root)
+{
+}
+
+SurfaceComposerClient::SurfaceComposerClient(const sp<ISurfaceComposerClient>& client): mStatus(NO_ERROR), mClient(client)
+{
+}
+
+
+void SurfaceComposerClient::onFirstRef() {
+    // ComposerService 封装 SurfaceFlinger 服务接口
+    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
+    if (sf != 0 && mStatus == NO_INIT) {
+        auto rootProducer = mParent.promote();
+        sp<ISurfaceComposerClient> conn;
+        conn = (rootProducer != nullptr) ? sf->createScopedConnection(rootProducer) : sf->createConnection();
+        if (conn != 0) {
+            mClient = conn;
+            mStatus = NO_ERROR;
+        }
+    }
+}
+
+
+sp<SurfaceControl> SurfaceComposerClient::createSurface(
+        const String8& name,
+        uint32_t w,
+        uint32_t h,
+        PixelFormat format,
+        uint32_t flags,
+        SurfaceControl* parent,
+        int32_t windowType,
+        int32_t ownerUid)
+{
+    sp<SurfaceControl> s;
+    createSurfaceChecked(name, w, h, format, &s, flags, parent, windowType, ownerUid);
+    return s;
+}
+
+status_t SurfaceComposerClient::createSurfaceChecked(
+        const String8& name,
+        uint32_t w,
+        uint32_t h,
+        PixelFormat format,
+        sp<SurfaceControl>* outSurface,
+        uint32_t flags,
+        SurfaceControl* parent,
+        int32_t windowType,
+        int32_t ownerUid)
+{
+    sp<SurfaceControl> sur;
+    status_t err = mStatus;
+
+    if (mStatus == NO_ERROR) {
+        sp<IBinder> handle;
+        sp<IBinder> parentHandle;
+        sp<IGraphicBufferProducer> gbp;
+
+        if (parent != nullptr) {
+            parentHandle = parent->getHandle();
+        }
+        err = mClient->createSurface(name, w, h, format, flags, parentHandle,windowType, ownerUid, &handle, &gbp);
+        ALOGE_IF(err, "SurfaceComposerClient::createSurface error %s", strerror(-err));
+        if (err == NO_ERROR) {
+            *outSurface = new SurfaceControl(this, handle, gbp, true /* owned */);
+        }
+    }
+    return err;
+}
+
+
+sp<IBinder> SurfaceComposerClient::createDisplay(const String8& displayName, bool secure) {
+    return ComposerService::getComposerService()->createDisplay(displayName,secure);
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/SurfaceFlinger.cpp b/android-auto-9-notes/media/surfaceflinger/SurfaceFlinger.cpp
new file mode 100644
index 0000000..65abafe
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/SurfaceFlinger.cpp
@@ -0,0 +1,425 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+//  static constexpr SkipInitializationTag SkipInitialization;
+SurfaceFlinger::SurfaceFlinger(SurfaceFlinger::SkipInitializationTag)
+      : BnSurfaceComposer(),
+        mTransactionFlags(0),
+        mTransactionPending(false),
+        mAnimTransactionPending(false),
+        mLayersRemoved(false),
+        mLayersAdded(false),
+        mRepaintEverything(0),
+        mBootTime(systemTime()),
+        mBuiltinDisplays(),
+        mVisibleRegionsDirty(false),
+        mGeometryInvalid(false),
+        mAnimCompositionPending(false),
+        mBootStage(BootStage::BOOTLOADER),
+        mDebugRegion(0),
+        mDebugDDMS(0),
+        mDebugDisableHWC(0),
+        mDebugDisableTransformHint(0),
+        mDebugInSwapBuffers(0),
+        mLastSwapBufferTime(0),
+        mDebugInTransaction(0),
+        mLastTransactionTime(0),
+        mForceFullDamage(false),
+        mPrimaryDispSync("PrimaryDispSync"),
+        mPrimaryHWVsyncEnabled(false),
+        mHWVsyncAvailable(false),
+        mHasPoweredOff(false),
+        mNumLayers(0),
+        mVrFlingerRequestsDisplay(false),
+        mMainThreadId(std::this_thread::get_id()),
+        mCreateBufferQueue(&BufferQueue::createBufferQueue),
+        mCreateNativeWindowSurface(&impl::NativeWindowSurface::create) {
+
+}
+
+
+
+SurfaceFlinger::SurfaceFlinger() : SurfaceFlinger(SkipInitialization) {
+    ALOGI("SurfaceFlinger is starting");
+
+    vsyncPhaseOffsetNs = getInt64< ISurfaceFlingerConfigs,&ISurfaceFlingerConfigs::vsyncEventPhaseOffsetNs>(1000000);
+
+    sfVsyncPhaseOffsetNs = getInt64< ISurfaceFlingerConfigs,&ISurfaceFlingerConfigs::vsyncSfEventPhaseOffsetNs>(1000000);
+
+    hasSyncFramework = getBool< ISurfaceFlingerConfigs,
+            &ISurfaceFlingerConfigs::hasSyncFramework>(true);
+
+    dispSyncPresentTimeOffset = getInt64< ISurfaceFlingerConfigs,
+            &ISurfaceFlingerConfigs::presentTimeOffsetFromVSyncNs>(0);
+
+    useHwcForRgbToYuv = getBool< ISurfaceFlingerConfigs,
+            &ISurfaceFlingerConfigs::useHwcForRGBtoYUV>(false);
+
+    maxVirtualDisplaySize = getUInt64<ISurfaceFlingerConfigs,
+            &ISurfaceFlingerConfigs::maxVirtualDisplaySize>(0);
+
+    // Vr flinger is only enabled on Daydream ready devices.
+    useVrFlinger = getBool< ISurfaceFlingerConfigs,&ISurfaceFlingerConfigs::useVrFlinger>(false);
+
+    maxFrameBufferAcquiredBuffers = getInt64< ISurfaceFlingerConfigs,&ISurfaceFlingerConfigs::maxFrameBufferAcquiredBuffers>(2);
+
+    hasWideColorDisplay = getBool<ISurfaceFlingerConfigs, &ISurfaceFlingerConfigs::hasWideColorDisplay>(false);
+
+    V1_1::DisplayOrientation primaryDisplayOrientation = getDisplayOrientation< V1_1::ISurfaceFlingerConfigs, &V1_1::ISurfaceFlingerConfigs::primaryDisplayOrientation>(V1_1::DisplayOrientation::ORIENTATION_0);
+
+    switch (primaryDisplayOrientation) {
+        case V1_1::DisplayOrientation::ORIENTATION_90:
+            mPrimaryDisplayOrientation = DisplayState::eOrientation90;
+            break;
+        case V1_1::DisplayOrientation::ORIENTATION_180:
+            mPrimaryDisplayOrientation = DisplayState::eOrientation180;
+            break;
+        case V1_1::DisplayOrientation::ORIENTATION_270:
+            mPrimaryDisplayOrientation = DisplayState::eOrientation270;
+            break;
+        default:
+            mPrimaryDisplayOrientation = DisplayState::eOrientationDefault;
+            break;
+    }
+    ALOGV("Primary Display Orientation is set to %2d.", mPrimaryDisplayOrientation);
+
+    mPrimaryDispSync.init(SurfaceFlinger::hasSyncFramework, SurfaceFlinger::dispSyncPresentTimeOffset);
+
+    // debugging stuff...
+    char value[PROPERTY_VALUE_MAX];
+
+    property_get("ro.bq.gpu_to_cpu_unsupported", value, "0");
+    mGpuToCpuSupported = !atoi(value);
+
+    property_get("debug.sf.showupdates", value, "0");
+    mDebugRegion = atoi(value);
+
+    property_get("debug.sf.ddms", value, "0");
+    mDebugDDMS = atoi(value);
+    if (mDebugDDMS) {
+        if (!startDdmConnection()) {
+            // start failed, and DDMS debugging not enabled
+            mDebugDDMS = 0;
+        }
+    }
+    ALOGI_IF(mDebugRegion, "showupdates enabled");
+    ALOGI_IF(mDebugDDMS, "DDMS debugging enabled");
+
+    property_get("debug.sf.disable_backpressure", value, "0");
+    mPropagateBackpressure = !atoi(value);
+    ALOGI_IF(!mPropagateBackpressure, "Disabling backpressure propagation");
+
+    property_get("debug.sf.enable_hwc_vds", value, "0");
+    mUseHwcVirtualDisplays = atoi(value);
+    ALOGI_IF(!mUseHwcVirtualDisplays, "Enabling HWC virtual displays");
+
+    property_get("ro.sf.disable_triple_buffer", value, "1");
+    mLayerTripleBufferingDisabled = atoi(value);
+    ALOGI_IF(mLayerTripleBufferingDisabled, "Disabling Triple Buffering");
+
+    const size_t defaultListSize = MAX_LAYERS;
+    auto listSize = property_get_int32("debug.sf.max_igbp_list_size", int32_t(defaultListSize));
+    mMaxGraphicBufferProducerListSize = (listSize > 0) ? size_t(listSize) : defaultListSize;
+
+    property_get("debug.sf.early_phase_offset_ns", value, "-1");
+    const int earlySfOffsetNs = atoi(value);
+
+    property_get("debug.sf.early_gl_phase_offset_ns", value, "-1");
+    const int earlyGlSfOffsetNs = atoi(value);
+
+    property_get("debug.sf.early_app_phase_offset_ns", value, "-1");
+    const int earlyAppOffsetNs = atoi(value);
+
+    property_get("debug.sf.early_gl_app_phase_offset_ns", value, "-1");
+    const int earlyGlAppOffsetNs = atoi(value);
+
+    const VSyncModulator::Offsets earlyOffsets =
+            {earlySfOffsetNs != -1 ? earlySfOffsetNs : sfVsyncPhaseOffsetNs,earlyAppOffsetNs != -1 ? earlyAppOffsetNs : vsyncPhaseOffsetNs};
+    const VSyncModulator::Offsets earlyGlOffsets =
+            {earlyGlSfOffsetNs != -1 ? earlyGlSfOffsetNs : sfVsyncPhaseOffsetNs,earlyGlAppOffsetNs != -1 ? earlyGlAppOffsetNs : vsyncPhaseOffsetNs};
+    mVsyncModulator.setPhaseOffsets(earlyOffsets, earlyGlOffsets,{sfVsyncPhaseOffsetNs, vsyncPhaseOffsetNs});
+
+    // We should be reading 'persist.sys.sf.color_saturation' here
+    // but since /data may be encrypted, we need to wait until after vold
+    // comes online to attempt to read the property. The property is
+    // instead read after the boot animation
+
+    if (useTrebleTestingOverride()) {
+        // Without the override SurfaceFlinger cannot connect to HIDL
+        // services that are not listed in the manifests.  Considered
+        // deriving the setting from the set service name, but it
+        // would be brittle if the name that's not 'default' is used
+        // for production purposes later on.
+        setenv("TREBLE_TESTING_OVERRIDE", "true", true);
+    }
+}
+
+void SurfaceFlinger::onFirstRef()
+{
+    //  mutable std::unique_ptr<MessageQueue> mEventQueue{std::make_unique<impl::MessageQueue>()};
+    /***
+     * MessageQueue 初始化
+     * */
+    mEventQueue->init(this);
+}
+
+
+
+
+// Do not call property_set on main thread which will be blocked by init
+// Use StartPropertySetThread instead.
+void SurfaceFlinger::init() {
+    ALOGI(  "SurfaceFlinger's main thread ready to run. " "Initializing graphics H/W...");
+
+    ALOGI("Phase offest NS: %" PRId64 "", vsyncPhaseOffsetNs);
+
+    Mutex::Autolock _l(mStateLock);
+
+    // start the EventThread
+    mEventThreadSource = std::make_unique<DispSyncSource>(&mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs, true, "app");
+    mEventThread = std::make_unique<impl::EventThread>(mEventThreadSource.get(),
+                                                       [this]() { resyncWithRateLimit(); },
+                                                       impl::EventThread::InterceptVSyncsCallback(),
+                                                       "appEventThread");
+    mSfEventThreadSource = std::make_unique<DispSyncSource>(&mPrimaryDispSync,SurfaceFlinger::sfVsyncPhaseOffsetNs, true, "sf");
+
+    mSFEventThread = std::make_unique<impl::EventThread>(mSfEventThreadSource.get(),
+                                                [this]() { resyncWithRateLimit(); },
+                                                [this](nsecs_t timestamp) {
+                                                    mInterceptor->saveVSyncEvent(timestamp);
+                                                },
+                                                "sfEventThread");
+    mEventQueue->setEventThread(mSFEventThread.get());
+    mVsyncModulator.setEventThreads(mSFEventThread.get(), mEventThread.get());
+
+
+    //  @  /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
+    // Get a RenderEngine for the given display / config (can't fail)
+    getBE().mRenderEngine = RE::impl::RenderEngine::create(HAL_PIXEL_FORMAT_RGBA_8888,
+                                           hasWideColorDisplay ? RE::RenderEngine::WIDE_COLOR_SUPPORT : 0);
+                                           
+    LOG_ALWAYS_FATAL_IF(getBE().mRenderEngine == nullptr, "couldn't create RenderEngine");
+
+    LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,"Starting with vr flinger active is not currently supported.");
+
+    getBE().mHwc.reset(new HWComposer(std::make_unique<Hwc2::impl::Composer>(getBE().mHwcServiceName)));
+    getBE().mHwc->registerCallback(this, getBE().mComposerSequenceId);
+    // Process any initial hotplug and resulting display changes.
+    processDisplayHotplugEventsLocked();
+    LOG_ALWAYS_FATAL_IF(!getBE().mHwc->isConnected(HWC_DISPLAY_PRIMARY),"Registered composer callback but didn't create the default primary display");
+
+    // make the default display GLContext current so that we can create textures
+    // when creating Layers (which may happens before we render something)
+    getDefaultDisplayDeviceLocked()->makeCurrent();
+
+    if (useVrFlinger) {
+        auto vrFlingerRequestDisplayCallback = [this] (bool requestDisplay) {
+            // This callback is called from the vr flinger dispatch thread. We
+            // need to call signalTransaction(), which requires holding
+            // mStateLock when we're not on the main thread. Acquiring
+            // mStateLock from the vr flinger dispatch thread might trigger a
+            // deadlock in surface flinger (see b/66916578), so post a message
+            // to be handled on the main thread instead.
+            sp<LambdaMessage> message = new LambdaMessage([=]() {
+                ALOGI("VR request display mode: requestDisplay=%d", requestDisplay);
+                mVrFlingerRequestsDisplay = requestDisplay;
+                signalTransaction();
+            });
+            postMessageAsync(message);
+        };
+        mVrFlinger = dvr::VrFlinger::Create(getBE().mHwc->getComposer(),getBE().mHwc->getHwcDisplayId(HWC_DISPLAY_PRIMARY).value_or(0),vrFlingerRequestDisplayCallback);
+        if (!mVrFlinger) {
+            ALOGE("Failed to start vrflinger");
+        }
+    }
+
+    mEventControlThread = std::make_unique<impl::EventControlThread>([this](bool enabled) { setVsyncEnabled(HWC_DISPLAY_PRIMARY, enabled); });
+
+    // initialize our drawing state
+    mDrawingState = mCurrentState;
+
+    // set initial conditions (e.g. unblank default device)
+    initializeDisplays();
+
+    getBE().mRenderEngine->primeCache();
+
+    // Inform native graphics APIs whether the present timestamp is supported:
+    if (getHwComposer().hasCapability(HWC2::Capability::PresentFenceIsNotReliable)) {
+        mStartPropertySetThread = new StartPropertySetThread(false);
+    } else {
+        mStartPropertySetThread = new StartPropertySetThread(true);
+    }
+
+    if (mStartPropertySetThread->Start() != NO_ERROR) {
+        ALOGE("Run StartPropertySetThread failed!");
+    }
+
+    // This is a hack. Per definition of getDataspaceSaturationMatrix, the returned matrix
+    // is used to saturate legacy sRGB content. However, to make sure the same color under
+    // Display P3 will be saturated to the same color, we intentionally break the API spec
+    // and apply this saturation matrix on Display P3 content. Unless the risk of applying
+    // such saturation matrix on Display P3 is understood fully, the API should always return
+    // identify matrix.
+    mEnhancedSaturationMatrix = getBE().mHwc->getDataspaceSaturationMatrix(HWC_DISPLAY_PRIMARY,Dataspace::SRGB_LINEAR);
+
+    // we will apply this on Display P3.
+    if (mEnhancedSaturationMatrix != mat4()) {
+        ColorSpace srgb(ColorSpace::sRGB());
+        ColorSpace displayP3(ColorSpace::DisplayP3());
+        mat4 srgbToP3 = mat4(ColorSpaceConnector(srgb, displayP3).getTransform());
+        mat4 p3ToSrgb = mat4(ColorSpaceConnector(displayP3, srgb).getTransform());
+        mEnhancedSaturationMatrix = srgbToP3 * mEnhancedSaturationMatrix * p3ToSrgb;
+    }
+
+    ALOGV("Done initializing");
+}
+
+
+
+
+status_t SurfaceFlinger::createLayer(
+        const String8& name,
+        const sp<Client>& client,
+        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
+        int32_t windowType, int32_t ownerUid, sp<IBinder>* handle,
+        sp<IGraphicBufferProducer>* gbp, sp<Layer>* parent)
+{
+    if (int32_t(w|h) < 0) {
+        ALOGE("createLayer() failed, w or h is negative (w=%d, h=%d)",int(w), int(h));
+        return BAD_VALUE;
+    }
+
+    status_t result = NO_ERROR;
+
+    sp<Layer> layer;
+
+    String8 uniqueName = getUniqueLayerName(name);
+
+    switch (flags & ISurfaceComposerClient::eFXSurfaceMask) {
+        case ISurfaceComposerClient::eFXSurfaceNormal:
+            result = createBufferLayer(client,uniqueName, w, h, flags, format,handle, gbp, &layer);
+
+            break;
+        case ISurfaceComposerClient::eFXSurfaceColor:
+            result = createColorLayer(client,uniqueName, w, h, flags,handle, &layer);
+            break;
+        default:
+            result = BAD_VALUE;
+            break;
+    }
+
+    if (result != NO_ERROR) {
+        return result;
+    }
+
+    // window type is WINDOW_TYPE_DONT_SCREENSHOT from SurfaceControl.java
+    // TODO b/64227542
+    if (windowType == 441731) {
+        windowType = 2024; // TYPE_NAVIGATION_BAR_PANEL
+        layer->setPrimaryDisplayOnly();
+    }
+
+    layer->setInfo(windowType, ownerUid);
+
+    result = addClientLayer(client, *handle, *gbp, layer, *parent);
+    if (result != NO_ERROR) {
+        return result;
+    }
+    mInterceptor->saveSurfaceCreation(layer);
+
+    setTransactionFlags(eTransactionNeeded);
+    return result;
+}
+
+
+status_t SurfaceFlinger::createBufferLayer(const sp<Client>& client,
+        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
+        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
+{
+    // initialize the surfaces
+    switch (format) {
+    case PIXEL_FORMAT_TRANSPARENT:
+    case PIXEL_FORMAT_TRANSLUCENT:
+        format = PIXEL_FORMAT_RGBA_8888;
+        break;
+    case PIXEL_FORMAT_OPAQUE:
+        format = PIXEL_FORMAT_RGBX_8888;
+        break;
+    }
+
+    sp<BufferLayer> layer = new BufferLayer(this, client, name, w, h, flags);
+    status_t err = layer->setBuffers(w, h, format, flags);
+    if (err == NO_ERROR) {
+        *handle = layer->getHandle();
+        *gbp = layer->getProducer();
+        *outLayer = layer;
+    }
+
+    ALOGE_IF(err, "createBufferLayer() failed (%s)", strerror(-err));
+    return err;
+}
+
+uint32_t SurfaceFlinger::getNewTexture() {
+    {
+        //   std::vector<uint32_t> mTexturePool;
+        std::lock_guard lock(mTexturePoolMutex);
+        if (!mTexturePool.empty()) {
+            uint32_t name = mTexturePool.back();
+            mTexturePool.pop_back();
+            ATRACE_INT("TexturePoolSize", mTexturePool.size());
+            return name;
+        }
+
+        // The pool was too small, so increase it for the future
+        ++mTexturePoolSize;
+    }
+
+    // The pool was empty, so we need to get a new texture name directly using a
+    // blocking call to the main thread
+    uint32_t name = 0;
+    postMessageSync(new LambdaMessage([&]() { getRenderEngine().genTextures(1, &name); }));
+    return name;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/***
+ * 用于wifidisplay
+ * */
+sp<IBinder> SurfaceFlinger::createDisplay(const String8& displayName,bool secure)
+{
+    class DisplayToken : public BBinder {
+        sp<SurfaceFlinger> flinger;
+        virtual ~DisplayToken() {
+             // no more references, this display must be terminated
+             Mutex::Autolock _l(flinger->mStateLock);
+             flinger->mCurrentState.displays.removeItem(this);
+             flinger->setTransactionFlags(eDisplayTransactionNeeded);
+         }
+     public:
+        explicit DisplayToken(const sp<SurfaceFlinger>& flinger)
+            : flinger(flinger) {
+        }
+    };
+
+    sp<BBinder> token = new DisplayToken(this);
+
+    Mutex::Autolock _l(mStateLock);
+    DisplayDeviceState info(DisplayDevice::DISPLAY_VIRTUAL, secure);
+    info.displayName = displayName;
+    mCurrentState.displays.add(token, info);
+    mInterceptor->saveDisplayCreation(info);
+    return token;
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/SurfaceFlingerBE.cpp b/android-auto-9-notes/media/surfaceflinger/SurfaceFlingerBE.cpp
new file mode 100644
index 0000000..5b77909
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/SurfaceFlingerBE.cpp
@@ -0,0 +1,23 @@
+
+/**
+ * 封装在SurfaceFlinger中，声明时创建
+ * */
+
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+SurfaceFlingerBE::SurfaceFlingerBE()
+      : mHwcServiceName(getHwcServiceName()),  // 
+        mRenderEngine(nullptr),
+        mFrameBuckets(),
+        mTotalTime(0),
+        mLastSwapTime(0),
+        mComposerSequenceId(0) {
+}
+
+
+std::string getHwcServiceName() {
+    char value[PROPERTY_VALUE_MAX] = {};
+    property_get("debug.sf.hwc_service_name", value, "default");
+    ALOGI("Using HWComposer service: '%s'", value);
+    return std::string(value);
+}
+
diff --git a/android-auto-9-notes/media/surfaceflinger/SurfaceInterceptor.cpp b/android-auto-9-notes/media/surfaceflinger/SurfaceInterceptor.cpp
new file mode 100644
index 0000000..e36a9cb
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/SurfaceInterceptor.cpp
@@ -0,0 +1,32 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/SurfaceInterceptor.cpp
+SurfaceInterceptor::SurfaceInterceptor(SurfaceFlinger* flinger)
+    :   mFlinger(flinger)
+{
+}
+
+
+void SurfaceInterceptor::saveDisplayCreation(const DisplayDeviceState& info) {
+    if (!mEnabled) {
+        return;
+    }
+    ATRACE_CALL();
+    std::lock_guard<std::mutex> protoGuard(mTraceMutex);
+    addDisplayCreationLocked(createTraceIncrementLocked(), info);
+}
+
+
+Increment* SurfaceInterceptor::createTraceIncrementLocked() {
+    Increment* increment(mTrace.add_increment());
+    increment->set_time_stamp(systemTime());
+    return increment;
+}
+
+void SurfaceInterceptor::addDisplayCreationLocked(Increment* increment,
+        const DisplayDeviceState& info)
+{
+    DisplayCreation* creation(increment->mutable_display_creation());
+    creation->set_id(info.displayId);
+    creation->set_name(info.displayName);
+    creation->set_type(info.type);
+    creation->set_is_secure(info.isSecure);
+}
\ No newline at end of file
diff --git a/android-auto-9-notes/media/surfaceflinger/main_surfaceflinger.cpp b/android-auto-9-notes/media/surfaceflinger/main_surfaceflinger.cpp
new file mode 100644
index 0000000..8ed3fb9
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/main_surfaceflinger.cpp
@@ -0,0 +1,85 @@
+//  @   /work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/surfaceflinger.rc
+service surfaceflinger /system/bin/surfaceflinger
+    class core animation
+    user system
+    group graphics drmrpc readproc
+    onrestart restart zygote
+    writepid /dev/stune/foreground/tasks
+    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0
+    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0
+    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0
+
+
+int main(int, char**) {
+    signal(SIGPIPE, SIG_IGN);
+
+    hardware::configureRpcThreadpool(1 /* maxThreads */,false /* callerWillJoin */);
+
+    startGraphicsAllocatorService();
+
+    // When SF is launched in its own process, limit the number of
+    // binder threads to 4.
+    ProcessState::self()->setThreadPoolMaxThreadCount(4);
+
+    // start the thread pool
+    sp<ProcessState> ps(ProcessState::self());
+    ps->startThreadPool();
+
+    // instantiate surfaceflinger
+    sp<SurfaceFlinger> flinger = new SurfaceFlinger();
+
+    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);
+
+    set_sched_policy(0, SP_FOREGROUND);
+
+    // Put most SurfaceFlinger threads in the system-background cpuset
+    // Keeps us from unnecessarily using big cores
+    // Do this after the binder thread pool init
+    if (cpusets_enabled()) set_cpuset_policy(0, SP_SYSTEM);
+
+    // initialize before clients can connect
+    flinger->init();
+
+    // publish surface flinger
+    sp<IServiceManager> sm(defaultServiceManager());
+    sm->addService(String16(SurfaceFlinger::getServiceName()), flinger, false,
+                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);
+
+    // publish GpuService
+    sp<GpuService> gpuservice = new GpuService();
+    sm->addService(String16(GpuService::SERVICE_NAME), gpuservice, false);
+
+    startDisplayService(); // dependency on SF getting registered above
+
+    struct sched_param param = {0};
+    param.sched_priority = 2;
+    if (sched_setscheduler(0, SCHED_FIFO, &param) != 0) {
+        ALOGE("Couldn't set SCHED_FIFO");
+    }
+
+    // run surface flinger in this thread
+    flinger->run();
+
+    return 0;
+}
+
+
+static status_t startGraphicsAllocatorService() {
+    using android::hardware::configstore::getBool;
+    using android::hardware::configstore::V1_0::ISurfaceFlingerConfigs;
+    if (!getBool<ISurfaceFlingerConfigs,&ISurfaceFlingerConfigs::startGraphicsAllocatorService>(false)) {
+        return OK;
+    }
+
+    using android::hardware::graphics::allocator::V2_0::IAllocator;
+
+    status_t result = hardware::registerPassthroughServiceImplementation<IAllocator>();
+    if (result != OK) {
+        ALOGE("could not start graphics allocator service");
+        return result;
+    }
+
+    return OK;
+}
+
+
diff --git a/android-auto-9-notes/media/surfaceflinger/surfaceflinger.txt b/android-auto-9-notes/media/surfaceflinger/surfaceflinger.txt
new file mode 100644
index 0000000..5ea3231
--- /dev/null
+++ b/android-auto-9-notes/media/surfaceflinger/surfaceflinger.txt
@@ -0,0 +1,24 @@
+//  ISurfaceComposerClient
+/work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/Client.h
+/work/workcodes/aosp-p9.x-auto-ga/frameworks/native/services/surfaceflinger/Client.cpp
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/work/workcodes/aosp-p9.x-auto-ga/frameworks/native/libs/gui/SurfaceComposerClient.cpp
\ No newline at end of file
diff --git a/temp/0001-debug-LOCAL_PREBUILT_JNI_LIBS.patch b/temp/0001-debug-LOCAL_PREBUILT_JNI_LIBS.patch
deleted file mode 100644
index bba6d6b..0000000
--- a/temp/0001-debug-LOCAL_PREBUILT_JNI_LIBS.patch
+++ /dev/null
@@ -1,585 +0,0 @@
-From b38f56bca8ced52f8da676fa3f65f61a06c66acd Mon Sep 17 00:00:00 2001
-From: lixuqing <lixuqing2007@126.com>
-Date: Sun, 11 Aug 2019 23:58:41 +0800
-Subject: [PATCH] debug LOCAL_PREBUILT_JNI_LIBS
-
----
- core/definitions.mk               |   1 +
- core/install_jni_libs.mk          |  36 +++++
- core/install_jni_libs_internal.mk |  29 ++++
- core/prebuilt_internal.mk         |  38 ++++++
- temp.patch                        | 281 ++++++++++++++++++++++++++++++++++++++
- 5 files changed, 385 insertions(+)
- create mode 100644 temp.patch
-
-diff --git a/core/definitions.mk b/core/definitions.mk
-index 599ab49..a4c5c1d 100644
---- a/core/definitions.mk
-+++ b/core/definitions.mk
-@@ -2589,6 +2589,7 @@ endef
- # Uncompress shared libraries embedded in an apk.
- #
- define uncompress-shared-libs
-+$(warning uncompress-shared-libs $@ $(PRIVATE_EMBEDDED_JNI_LIBS))
- $(hide) if (zipinfo $@ $(PRIVATE_EMBEDDED_JNI_LIBS) 2>/dev/null | grep -v ' stor ' >/dev/null) ; then \
-   rm -rf $(dir $@)uncompressedlibs && mkdir $(dir $@)uncompressedlibs; \
-   unzip -q $@ $(PRIVATE_EMBEDDED_JNI_LIBS) -d $(dir $@)uncompressedlibs && \
-diff --git a/core/install_jni_libs.mk b/core/install_jni_libs.mk
-index b7d83dc..e660d4f 100644
---- a/core/install_jni_libs.mk
-+++ b/core/install_jni_libs.mk
-@@ -34,6 +34,8 @@ jni_shared_libraries_abis :=
- jni_shared_libraries_with_abis :=
- embedded_prebuilt_jni_libs :=
- 
-+$(warning LOCAL_MODULE : $(LOCAL_MODULE))
-+
- #######################################
- # For TARGET_ARCH
- my_2nd_arch_prefix :=
-@@ -42,15 +44,30 @@ my_add_jni :=
- ifeq ($(my_2nd_arch_prefix),$(LOCAL_2ND_ARCH_VAR_PREFIX))
- my_add_jni := true
- endif
-+
-+$(warning my_2nd_arch_prefix : $(my_2nd_arch_prefix))
-+$(warning LOCAL_2ND_ARCH_VAR_PREFIX : $(LOCAL_2ND_ARCH_VAR_PREFIX))
-+
-+
-+
- # Or it explicitly requires both
- ifeq ($(my_module_multilib),both)
- my_add_jni := true
- endif
-+
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_add_jni: $(my_add_jni))
-+
-+
-+
- ifeq ($(my_add_jni),true)
- my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS_$(TARGET_ARCH))
-+
-+
- ifndef my_prebuilt_jni_libs
- my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS)
- endif
-+
-+
- include $(BUILD_SYSTEM)/install_jni_libs_internal.mk
- jni_shared_libraries += $(my_jni_shared_libraries)
- jni_shared_libraries_abis += $(my_jni_shared_libraries_abi)
-@@ -70,20 +87,32 @@ endif  # my_add_jni
- ifdef TARGET_2ND_ARCH
- my_2nd_arch_prefix := $(TARGET_2ND_ARCH_VAR_PREFIX)
- my_add_jni :=
-+
-+
-+
- # The module is built for TARGET_2ND_ARCH
- ifeq ($(my_2nd_arch_prefix),$(LOCAL_2ND_ARCH_VAR_PREFIX))
- my_add_jni := true
- endif
-+
-+
-+
- # Or it explicitly requires both
- ifeq ($(my_module_multilib),both)
- my_add_jni := true
- endif
-+
-+
- ifeq ($(my_add_jni),true)
- my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS_$(TARGET_2ND_ARCH))
- ifndef my_prebuilt_jni_libs
- my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS)
- endif
-+
-+
-+
- include $(BUILD_SYSTEM)/install_jni_libs_internal.mk
-+
- jni_shared_libraries += $(my_jni_shared_libraries)
- jni_shared_libraries_abis += $(my_jni_shared_libraries_abi)
- jni_shared_libraries_with_abis += $(addprefix $(my_jni_shared_libraries_abi):,\
-@@ -96,3 +125,10 @@ jni_shared_libraries := $(strip $(jni_shared_libraries))
- jni_shared_libraries_abis := $(sort $(jni_shared_libraries_abis))
- jni_shared_libraries_with_abis := $(strip $(jni_shared_libraries_with_abis))
- embedded_prebuilt_jni_libs := $(strip $(embedded_prebuilt_jni_libs))
-+
-+$(warning jni_shared_libraries : $(jni_shared_libraries))
-+$(warning jni_shared_libraries_abis : $(jni_shared_libraries_abis))
-+$(warning jni_shared_libraries_with_abis : $(jni_shared_libraries_with_abis))
-+$(warning embedded_prebuilt_jni_libs : $(embedded_prebuilt_jni_libs))
-+
-+
-diff --git a/core/install_jni_libs_internal.mk b/core/install_jni_libs_internal.mk
-index a99d88a..54f380d 100644
---- a/core/install_jni_libs_internal.mk
-+++ b/core/install_jni_libs_internal.mk
-@@ -21,7 +21,11 @@ my_jni_shared_libraries := \
- my_app_lib_path := $(dir $(LOCAL_INSTALLED_MODULE))lib/$(TARGET_$(my_2nd_arch_prefix)ARCH)
- my_embedded_prebuilt_jni_libs :=
- 
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_embed_jni: $(my_embed_jni))
-+
- ifdef my_embed_jni
-+
-+
- # App explicitly requires the prebuilt NDK stl shared libraies.
- # The NDK stl shared libraries should never go to the system image.
- ifeq ($(LOCAL_NDK_STL_VARIANT),c++_shared)
-@@ -44,6 +48,8 @@ endif
- 
- else  # not my_embed_jni
- 
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , not my_embed_jni)
-+
- my_jni_shared_libraries := $(strip $(my_jni_shared_libraries))
- ifneq ($(my_jni_shared_libraries),)
- # The jni libaries will be installed to the system.img.
-@@ -51,6 +57,10 @@ my_jni_filenames := $(notdir $(my_jni_shared_libraries))
- # Make sure the JNI libraries get installed
- my_shared_library_path := $(call get_non_asan_path,\
-   $($(my_2nd_arch_prefix)TARGET_OUT$(partition_tag)_SHARED_LIBRARIES))
-+
-+
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_shared_library_path: $(my_shared_library_path))
-+
- # Do not use order-only dependency, because we want to rebuild the image if an jni is updated.
- $(LOCAL_INSTALLED_MODULE) : $(addprefix $(my_shared_library_path)/, $(my_jni_filenames))
- 
-@@ -79,20 +89,35 @@ my_jni_shared_libraries :=
- endif  # $(my_jni_shared_libraries) not empty
- endif  # my_embed_jni
- 
-+
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_prebuilt_jni_libs: $(my_prebuilt_jni_libs))
-+
- ifdef my_prebuilt_jni_libs
- # Files like @lib/<abi>/libfoo.so (path inside the apk) are JNI libs embedded prebuilt apk;
- # Files like path/to/libfoo.so (path relative to LOCAL_PATH) are prebuilts in the source tree.
- my_embedded_prebuilt_jni_libs := $(patsubst @%,%, \
-     $(filter @%, $(my_prebuilt_jni_libs)))
- 
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_embedded_prebuilt_jni_libs: $(my_embedded_prebuilt_jni_libs))
-+
- # prebuilt JNI exsiting as separate source files.
- my_prebuilt_jni_libs := $(addprefix $(LOCAL_PATH)/, \
-     $(filter-out @%, $(my_prebuilt_jni_libs)))
-+
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , filter-out my_prebuilt_jni_libs: $(my_prebuilt_jni_libs))
-+
- ifdef my_prebuilt_jni_libs
- ifdef my_embed_jni
- # Embed my_prebuilt_jni_libs to the apk
- my_jni_shared_libraries += $(my_prebuilt_jni_libs)
- else # not my_embed_jni
-+
-+$(warning LOCAL_MODULE: $(LOCAL_MODULE) , 2 my_embed_jni: not my_embed_jni)
-+
-+$(warning LOCAL_INSTALLED_MODULE: $(LOCAL_INSTALLED_MODULE))
-+
-+$(warning my_app_lib_path: $(my_app_lib_path) )
-+
- # Install my_prebuilt_jni_libs as separate files.
- $(foreach lib, $(my_prebuilt_jni_libs), \
-     $(eval $(call copy-one-file, $(lib), $(my_app_lib_path)/$(notdir $(lib)))))
-@@ -100,6 +125,10 @@ $(foreach lib, $(my_prebuilt_jni_libs), \
- $(LOCAL_INSTALLED_MODULE) : $(addprefix $(my_app_lib_path)/, $(notdir $(my_prebuilt_jni_libs)))
- endif  # my_embed_jni
- endif  # inner my_prebuilt_jni_libs
-+
-+
-+
-+
- endif  # outer my_prebuilt_jni_libs
- 
- # Verify that all included libraries are built against the NDK
-diff --git a/core/prebuilt_internal.mk b/core/prebuilt_internal.mk
-index 0efda57..be65bcc 100644
---- a/core/prebuilt_internal.mk
-+++ b/core/prebuilt_internal.mk
-@@ -304,6 +304,11 @@ dex_preopt_profile_src_file := $(my_prebuilt_src_file)
- rs_compatibility_jni_libs :=
- include $(BUILD_SYSTEM)/install_jni_libs.mk
- 
-+
-+
-+
-+
-+
- ifeq ($(LOCAL_CERTIFICATE),EXTERNAL)
-   # The magic string "EXTERNAL" means this package will be signed with
-   # the default dev key throughout the build process, but we expect
-@@ -363,12 +368,23 @@ endif
- # defines built_odex along with rule to install odex
- include $(BUILD_SYSTEM)/dex_preopt_odex_install.mk
- #######################################
-+
-+
-+
-+
- ifneq ($(LOCAL_REPLACE_PREBUILT_APK_INSTALLED),)
-+
-+$(warning LOCAL_REPLACE_PREBUILT_APK_INSTALLED is empty)
-+
- # There is a replacement for the prebuilt .apk we can install without any processing.
- $(built_module) : $(LOCAL_REPLACE_PREBUILT_APK_INSTALLED)
- 	$(transform-prebuilt-to-target)
- 
- else  # ! LOCAL_REPLACE_PREBUILT_APK_INSTALLED
-+
-+
-+$(warning !LOCAL_REPLACE_PREBUILT_APK_INSTALLED)
-+
- # Sign and align non-presigned .apks.
- # The embedded prebuilt jni to uncompress.
- ifeq ($(LOCAL_CERTIFICATE),PRESIGNED)
-@@ -377,28 +393,47 @@ ifeq ($(LOCAL_CERTIFICATE),PRESIGNED)
- # we can't strip the file.
- embedded_prebuilt_jni_libs := 'lib/*.so'
- endif
-+
-+
-+
- ifndef embedded_prebuilt_jni_libs
- # No LOCAL_PREBUILT_JNI_LIBS, uncompress all.
- embedded_prebuilt_jni_libs := 'lib/*.so'
- endif
-+
-+$(warning embedded_prebuilt_jni_libs:$(embedded_prebuilt_jni_libs))
-+
- $(built_module): PRIVATE_EMBEDDED_JNI_LIBS := $(embedded_prebuilt_jni_libs)
- 
- ifdef LOCAL_COMPRESSED_MODULE
- $(built_module) : $(MINIGZIP)
- endif
- 
-+$(warning built_module:$(built_module))
-+$(warning PRIVATE_EMBEDDED_JNI_LIBS:$(PRIVATE_EMBEDDED_JNI_LIBS))
-+$(warning my_prebuilt_src_file:$(my_prebuilt_src_file))
-+$(warning ZIPALIGN:$(ZIPALIGN))
-+$(warning SIGNAPK_JAR:$(SIGNAPK_JAR))
-+
- $(built_module) : $(my_prebuilt_src_file) | $(ZIPALIGN) $(SIGNAPK_JAR)
- 	$(transform-prebuilt-to-target)
- 	$(uncompress-shared-libs)
-+
-+
-+
- ifeq (true, $(LOCAL_UNCOMPRESS_DEX))
- 	$(uncompress-dexs)
- endif  # LOCAL_UNCOMPRESS_DEX
-+
- ifdef LOCAL_DEX_PREOPT
- ifneq ($(BUILD_PLATFORM_ZIP),)
- 	@# Keep a copy of apk with classes.dex unstripped
- 	$(hide) cp -f $@ $(dir $@)package.dex.apk
- endif  # BUILD_PLATFORM_ZIP
- endif  # LOCAL_DEX_PREOPT
-+
-+
-+
- ifneq ($(LOCAL_CERTIFICATE),PRESIGNED)
- 	@# Only strip out files if we can re-sign the package.
- ifdef LOCAL_DEX_PREOPT
-@@ -414,6 +449,9 @@ endif  # LOCAL_CERTIFICATE
- ifdef LOCAL_COMPRESSED_MODULE
- 	$(compress-package)
- endif  # LOCAL_COMPRESSED_MODULE
-+
-+
-+
- endif  # ! LOCAL_REPLACE_PREBUILT_APK_INSTALLED
- 
- ###############################
-diff --git a/temp.patch b/temp.patch
-new file mode 100644
-index 0000000..be144a8
---- /dev/null
-+++ b/temp.patch
-@@ -0,0 +1,281 @@
-+diff --git a/core/definitions.mk b/core/definitions.mk
-+index 599ab49..a4c5c1d 100644
-+--- a/core/definitions.mk
-++++ b/core/definitions.mk
-+@@ -2589,6 +2589,7 @@ endef
-+ # Uncompress shared libraries embedded in an apk.
-+ #
-+ define uncompress-shared-libs
-++$(warning uncompress-shared-libs $@ $(PRIVATE_EMBEDDED_JNI_LIBS))
-+ $(hide) if (zipinfo $@ $(PRIVATE_EMBEDDED_JNI_LIBS) 2>/dev/null | grep -v ' stor ' >/dev/null) ; then \
-+   rm -rf $(dir $@)uncompressedlibs && mkdir $(dir $@)uncompressedlibs; \
-+   unzip -q $@ $(PRIVATE_EMBEDDED_JNI_LIBS) -d $(dir $@)uncompressedlibs && \
-+diff --git a/core/install_jni_libs.mk b/core/install_jni_libs.mk
-+index b7d83dc..e660d4f 100644
-+--- a/core/install_jni_libs.mk
-++++ b/core/install_jni_libs.mk
-+@@ -34,6 +34,8 @@ jni_shared_libraries_abis :=
-+ jni_shared_libraries_with_abis :=
-+ embedded_prebuilt_jni_libs :=
-+ 
-++$(warning LOCAL_MODULE : $(LOCAL_MODULE))
-++
-+ #######################################
-+ # For TARGET_ARCH
-+ my_2nd_arch_prefix :=
-+@@ -42,15 +44,30 @@ my_add_jni :=
-+ ifeq ($(my_2nd_arch_prefix),$(LOCAL_2ND_ARCH_VAR_PREFIX))
-+ my_add_jni := true
-+ endif
-++
-++$(warning my_2nd_arch_prefix : $(my_2nd_arch_prefix))
-++$(warning LOCAL_2ND_ARCH_VAR_PREFIX : $(LOCAL_2ND_ARCH_VAR_PREFIX))
-++
-++
-++
-+ # Or it explicitly requires both
-+ ifeq ($(my_module_multilib),both)
-+ my_add_jni := true
-+ endif
-++
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_add_jni: $(my_add_jni))
-++
-++
-++
-+ ifeq ($(my_add_jni),true)
-+ my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS_$(TARGET_ARCH))
-++
-++
-+ ifndef my_prebuilt_jni_libs
-+ my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS)
-+ endif
-++
-++
-+ include $(BUILD_SYSTEM)/install_jni_libs_internal.mk
-+ jni_shared_libraries += $(my_jni_shared_libraries)
-+ jni_shared_libraries_abis += $(my_jni_shared_libraries_abi)
-+@@ -70,20 +87,32 @@ endif  # my_add_jni
-+ ifdef TARGET_2ND_ARCH
-+ my_2nd_arch_prefix := $(TARGET_2ND_ARCH_VAR_PREFIX)
-+ my_add_jni :=
-++
-++
-++
-+ # The module is built for TARGET_2ND_ARCH
-+ ifeq ($(my_2nd_arch_prefix),$(LOCAL_2ND_ARCH_VAR_PREFIX))
-+ my_add_jni := true
-+ endif
-++
-++
-++
-+ # Or it explicitly requires both
-+ ifeq ($(my_module_multilib),both)
-+ my_add_jni := true
-+ endif
-++
-++
-+ ifeq ($(my_add_jni),true)
-+ my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS_$(TARGET_2ND_ARCH))
-+ ifndef my_prebuilt_jni_libs
-+ my_prebuilt_jni_libs := $(LOCAL_PREBUILT_JNI_LIBS)
-+ endif
-++
-++
-++
-+ include $(BUILD_SYSTEM)/install_jni_libs_internal.mk
-++
-+ jni_shared_libraries += $(my_jni_shared_libraries)
-+ jni_shared_libraries_abis += $(my_jni_shared_libraries_abi)
-+ jni_shared_libraries_with_abis += $(addprefix $(my_jni_shared_libraries_abi):,\
-+@@ -96,3 +125,10 @@ jni_shared_libraries := $(strip $(jni_shared_libraries))
-+ jni_shared_libraries_abis := $(sort $(jni_shared_libraries_abis))
-+ jni_shared_libraries_with_abis := $(strip $(jni_shared_libraries_with_abis))
-+ embedded_prebuilt_jni_libs := $(strip $(embedded_prebuilt_jni_libs))
-++
-++$(warning jni_shared_libraries : $(jni_shared_libraries))
-++$(warning jni_shared_libraries_abis : $(jni_shared_libraries_abis))
-++$(warning jni_shared_libraries_with_abis : $(jni_shared_libraries_with_abis))
-++$(warning embedded_prebuilt_jni_libs : $(embedded_prebuilt_jni_libs))
-++
-++
-+diff --git a/core/install_jni_libs_internal.mk b/core/install_jni_libs_internal.mk
-+index a99d88a..54f380d 100644
-+--- a/core/install_jni_libs_internal.mk
-++++ b/core/install_jni_libs_internal.mk
-+@@ -21,7 +21,11 @@ my_jni_shared_libraries := \
-+ my_app_lib_path := $(dir $(LOCAL_INSTALLED_MODULE))lib/$(TARGET_$(my_2nd_arch_prefix)ARCH)
-+ my_embedded_prebuilt_jni_libs :=
-+ 
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_embed_jni: $(my_embed_jni))
-++
-+ ifdef my_embed_jni
-++
-++
-+ # App explicitly requires the prebuilt NDK stl shared libraies.
-+ # The NDK stl shared libraries should never go to the system image.
-+ ifeq ($(LOCAL_NDK_STL_VARIANT),c++_shared)
-+@@ -44,6 +48,8 @@ endif
-+ 
-+ else  # not my_embed_jni
-+ 
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , not my_embed_jni)
-++
-+ my_jni_shared_libraries := $(strip $(my_jni_shared_libraries))
-+ ifneq ($(my_jni_shared_libraries),)
-+ # The jni libaries will be installed to the system.img.
-+@@ -51,6 +57,10 @@ my_jni_filenames := $(notdir $(my_jni_shared_libraries))
-+ # Make sure the JNI libraries get installed
-+ my_shared_library_path := $(call get_non_asan_path,\
-+   $($(my_2nd_arch_prefix)TARGET_OUT$(partition_tag)_SHARED_LIBRARIES))
-++
-++
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_shared_library_path: $(my_shared_library_path))
-++
-+ # Do not use order-only dependency, because we want to rebuild the image if an jni is updated.
-+ $(LOCAL_INSTALLED_MODULE) : $(addprefix $(my_shared_library_path)/, $(my_jni_filenames))
-+ 
-+@@ -79,20 +89,35 @@ my_jni_shared_libraries :=
-+ endif  # $(my_jni_shared_libraries) not empty
-+ endif  # my_embed_jni
-+ 
-++
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_prebuilt_jni_libs: $(my_prebuilt_jni_libs))
-++
-+ ifdef my_prebuilt_jni_libs
-+ # Files like @lib/<abi>/libfoo.so (path inside the apk) are JNI libs embedded prebuilt apk;
-+ # Files like path/to/libfoo.so (path relative to LOCAL_PATH) are prebuilts in the source tree.
-+ my_embedded_prebuilt_jni_libs := $(patsubst @%,%, \
-+     $(filter @%, $(my_prebuilt_jni_libs)))
-+ 
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , my_embedded_prebuilt_jni_libs: $(my_embedded_prebuilt_jni_libs))
-++
-+ # prebuilt JNI exsiting as separate source files.
-+ my_prebuilt_jni_libs := $(addprefix $(LOCAL_PATH)/, \
-+     $(filter-out @%, $(my_prebuilt_jni_libs)))
-++
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , filter-out my_prebuilt_jni_libs: $(my_prebuilt_jni_libs))
-++
-+ ifdef my_prebuilt_jni_libs
-+ ifdef my_embed_jni
-+ # Embed my_prebuilt_jni_libs to the apk
-+ my_jni_shared_libraries += $(my_prebuilt_jni_libs)
-+ else # not my_embed_jni
-++
-++$(warning LOCAL_MODULE: $(LOCAL_MODULE) , 2 my_embed_jni: not my_embed_jni)
-++
-++$(warning LOCAL_INSTALLED_MODULE: $(LOCAL_INSTALLED_MODULE))
-++
-++$(warning my_app_lib_path: $(my_app_lib_path) )
-++
-+ # Install my_prebuilt_jni_libs as separate files.
-+ $(foreach lib, $(my_prebuilt_jni_libs), \
-+     $(eval $(call copy-one-file, $(lib), $(my_app_lib_path)/$(notdir $(lib)))))
-+@@ -100,6 +125,10 @@ $(foreach lib, $(my_prebuilt_jni_libs), \
-+ $(LOCAL_INSTALLED_MODULE) : $(addprefix $(my_app_lib_path)/, $(notdir $(my_prebuilt_jni_libs)))
-+ endif  # my_embed_jni
-+ endif  # inner my_prebuilt_jni_libs
-++
-++
-++
-++
-+ endif  # outer my_prebuilt_jni_libs
-+ 
-+ # Verify that all included libraries are built against the NDK
-+diff --git a/core/prebuilt_internal.mk b/core/prebuilt_internal.mk
-+index 0efda57..be65bcc 100644
-+--- a/core/prebuilt_internal.mk
-++++ b/core/prebuilt_internal.mk
-+@@ -304,6 +304,11 @@ dex_preopt_profile_src_file := $(my_prebuilt_src_file)
-+ rs_compatibility_jni_libs :=
-+ include $(BUILD_SYSTEM)/install_jni_libs.mk
-+ 
-++
-++
-++
-++
-++
-+ ifeq ($(LOCAL_CERTIFICATE),EXTERNAL)
-+   # The magic string "EXTERNAL" means this package will be signed with
-+   # the default dev key throughout the build process, but we expect
-+@@ -363,12 +368,23 @@ endif
-+ # defines built_odex along with rule to install odex
-+ include $(BUILD_SYSTEM)/dex_preopt_odex_install.mk
-+ #######################################
-++
-++
-++
-++
-+ ifneq ($(LOCAL_REPLACE_PREBUILT_APK_INSTALLED),)
-++
-++$(warning LOCAL_REPLACE_PREBUILT_APK_INSTALLED is empty)
-++
-+ # There is a replacement for the prebuilt .apk we can install without any processing.
-+ $(built_module) : $(LOCAL_REPLACE_PREBUILT_APK_INSTALLED)
-+ 	$(transform-prebuilt-to-target)
-+ 
-+ else  # ! LOCAL_REPLACE_PREBUILT_APK_INSTALLED
-++
-++
-++$(warning !LOCAL_REPLACE_PREBUILT_APK_INSTALLED)
-++
-+ # Sign and align non-presigned .apks.
-+ # The embedded prebuilt jni to uncompress.
-+ ifeq ($(LOCAL_CERTIFICATE),PRESIGNED)
-+@@ -377,28 +393,47 @@ ifeq ($(LOCAL_CERTIFICATE),PRESIGNED)
-+ # we can't strip the file.
-+ embedded_prebuilt_jni_libs := 'lib/*.so'
-+ endif
-++
-++
-++
-+ ifndef embedded_prebuilt_jni_libs
-+ # No LOCAL_PREBUILT_JNI_LIBS, uncompress all.
-+ embedded_prebuilt_jni_libs := 'lib/*.so'
-+ endif
-++
-++$(warning embedded_prebuilt_jni_libs:$(embedded_prebuilt_jni_libs))
-++
-+ $(built_module): PRIVATE_EMBEDDED_JNI_LIBS := $(embedded_prebuilt_jni_libs)
-+ 
-+ ifdef LOCAL_COMPRESSED_MODULE
-+ $(built_module) : $(MINIGZIP)
-+ endif
-+ 
-++$(warning built_module:$(built_module))
-++$(warning PRIVATE_EMBEDDED_JNI_LIBS:$(PRIVATE_EMBEDDED_JNI_LIBS))
-++$(warning my_prebuilt_src_file:$(my_prebuilt_src_file))
-++$(warning ZIPALIGN:$(ZIPALIGN))
-++$(warning SIGNAPK_JAR:$(SIGNAPK_JAR))
-++
-+ $(built_module) : $(my_prebuilt_src_file) | $(ZIPALIGN) $(SIGNAPK_JAR)
-+ 	$(transform-prebuilt-to-target)
-+ 	$(uncompress-shared-libs)
-++
-++
-++
-+ ifeq (true, $(LOCAL_UNCOMPRESS_DEX))
-+ 	$(uncompress-dexs)
-+ endif  # LOCAL_UNCOMPRESS_DEX
-++
-+ ifdef LOCAL_DEX_PREOPT
-+ ifneq ($(BUILD_PLATFORM_ZIP),)
-+ 	@# Keep a copy of apk with classes.dex unstripped
-+ 	$(hide) cp -f $@ $(dir $@)package.dex.apk
-+ endif  # BUILD_PLATFORM_ZIP
-+ endif  # LOCAL_DEX_PREOPT
-++
-++
-++
-+ ifneq ($(LOCAL_CERTIFICATE),PRESIGNED)
-+ 	@# Only strip out files if we can re-sign the package.
-+ ifdef LOCAL_DEX_PREOPT
-+@@ -414,6 +449,9 @@ endif  # LOCAL_CERTIFICATE
-+ ifdef LOCAL_COMPRESSED_MODULE
-+ 	$(compress-package)
-+ endif  # LOCAL_COMPRESSED_MODULE
-++
-++
-++
-+ endif  # ! LOCAL_REPLACE_PREBUILT_APK_INSTALLED
-+ 
-+ ###############################
--- 
-2.7.4
-
diff --git a/temp/Android.mk b/temp/Android.mk
deleted file mode 100644
index e781dad..0000000
--- a/temp/Android.mk
+++ /dev/null
@@ -1,50 +0,0 @@
-#
-# Copyright (C) 2014 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-# Install the prebuilt webview apk.
-
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := webview
-LOCAL_MODULE_CLASS := APPS
-#LOCAL_MULTILIB := both
-LOCAL_MULTILIB := 32
-$(warning DEFAULT_SYSTEM_DEV_CERTIFICATE: $(DEFAULT_SYSTEM_DEV_CERTIFICATE))
-LOCAL_CERTIFICATE := $(DEFAULT_SYSTEM_DEV_CERTIFICATE)
-# LOCAL_CERTIFICATE := PRESIGNED
-LOCAL_REQUIRED_MODULES := \
-        libwebviewchromium_loader \
-        libwebviewchromium_plat_support
-
-LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
-
-#LOCAL_MODULE_TARGET_ARCH := arm arm64 x86 x86_64
-LOCAL_MODULE_TARGET_ARCH := arm
-my_src_arch := $(call get-prebuilt-src-arch,$(LOCAL_MODULE_TARGET_ARCH))
-LOCAL_SRC_FILES := prebuilt/$(my_src_arch)/webview.apk
-
-LOCAL_BUILT_MODULE_STEM := $(LOCAL_MODULE).apk
-
-LOCAL_PREBUILT_JNI_LIBS_arm := @lib/armeabi-v7a/libwebviewchromium.so
-LOCAL_PREBUILT_JNI_LIBS_arm64 := @lib/arm64-v8a/libwebviewchromium.so
-LOCAL_PREBUILT_JNI_LIBS_x86 := @lib/x86/libwebviewchromium.so
-LOCAL_PREBUILT_JNI_LIBS_x86_64 := @lib/x86_64/libwebviewchromium.so
-
-#LOCAL_COMPRESSED_MODULE := true
-
-include $(BUILD_PREBUILT)
diff --git a/tools/update_libs.sh b/tools/update_libs.sh
index 14ba7c9..5c7a2ea 100755
--- a/tools/update_libs.sh
+++ b/tools/update_libs.sh
@@ -25,11 +25,11 @@ sudo apt-get -y install meld
 
 sudo apt-get -y install minicom
 
-cp ~/.bashrc ~/.bashrc-bk
-echo "ANDROID_SDK=/work/tools/android-sdk" >> ~/.bashrc
-echo "export PATH=$$PATH:$$ANDROID_SDK/tools:$$ANDROID_SDK/platform-tools" >> ~/.bashrc 
-echo "export PATH=$$PATH:/usr/local/go/bin" >> ~/.bashrc
-source ~/.bashrc
+#cp ~/.bashrc ~/.bashrc-bk
+#echo "ANDROID_SDK=/work/tools/android-sdk" >> ~/.bashrc
+#echo "export PATH=$$PATH:$$ANDROID_SDK/tools:$$ANDROID_SDK/platform-tools" >> ~/.bashrc 
+#echo "export PATH=$$PATH:/usr/local/go/bin" >> ~/.bashrc
+#source ~/.bashrc
 
 
 
-- 
2.23.0

